

[
  
  
    {
      "title"    : "页面没有找到",
      "url"      : "https://blog.shcat.top/404.html",
      "keywords" : "404"
    } ,
  
  
  
    {
      "title"    : "About",
      "url"      : "https://blog.shcat.top/about/",
      "keywords" : "Zhuang Ma, 马壮"
    } ,
  
  
  
    {
      "title"    : "归档",
      "url"      : "https://blog.shcat.top/archives/",
      "keywords" : "归档"
    } ,
  
  
  
    {
      "title"    : "Categories",
      "url"      : "https://blog.shcat.top/categories/",
      "keywords" : "分类"
    } ,
  
  
  
    {
      "title"    : "捐助 / Donate",
      "url"      : "https://blog.shcat.top/donate/",
      "keywords" : "Donate"
    } ,
  
  
  
    {
      "title"    : "Fragments",
      "url"      : "https://blog.shcat.top/fragments/",
      "keywords" : "fragments"
    } ,
  
  
  
  
  
    {
      "title"    : "Links",
      "url"      : "https://blog.shcat.top/links/",
      "keywords" : "友情链接"
    } ,
  
  
  
    {
      "title"    : "mindmap",
      "url"      : "https://blog.shcat.top/mindmap-viewer/",
      "keywords" : "mindmap"
    } ,
  
  
  
    {
      "title"    : "Open Source Projects",
      "url"      : "https://blog.shcat.top/open-source/",
      "keywords" : "开源,open-source,GitHub,开源项目"
    } ,
  
  
  
  
  
    {
      "title"    : "Wiki",
      "url"      : "https://blog.shcat.top/wiki/",
      "keywords" : "维基, Wiki"
    } ,
  
  
  
  
  
  
  
  
  
  

  
    {
      "title"    : "本站第一个blog",
      "category" : "Blog",
      "content": "开始 最近在学习尚筹网的项目，因为没有听课，所以找了几个个人整理的步骤跟着做，其中一个是在GitHub上的个人Blog站。 之前也接触过此类，也用过宝塔搞过wordpress，但苦于服务器时好时坏（这次宕机两周了）。平时也用notion做刷题笔记。今日拉了一个模板直接使用，并简单配置了一下评论模块。希望可以长期使用（坚持记录）。 碎碎念 提到notion，好久没刷题了。上周yyy面试被问的上台阶问题，只想到了递归，还没具体做一下。 记录一下耻辱的刷题数：31.（刷了一年了🙂） 今年秋招结束了基本，互联网寒冬确实不是闹着玩的。抓紧准备找实习。 此文作为一个开始。 ",
      "url"      : "https://blog.shcat.top/2022/11/18/the-first-blog/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "JSON",
      "category" : "",
      "content": "gson FastJson 循环引用的问题 如果往一个 List 里多次添加了同一对象，在 JSON.toJSONString 时默认会被转换成这样： [  {  k1: v1,  k2: []  },  {$ref: $.paras[0]},  {$ref: $.paras[0]},  {$ref: $.paras[0]},  {$ref: $.paras[0]},  {$ref: $.paras[0]},  {$ref: $.paras[0]},  {$ref: $.paras[0]},  {$ref: $.paras[0]},  {$ref: $.paras[0]},  {$ref: $.paras[0]},  {$ref: $.paras[0]},  {$ref: $.paras[0]} ] 我这里因为是误操作才往 List 里多次添加的，所以解决误操作就好了。 至于确实是真实意图的情况（可能一般前端才有？），可以参考 http://blog.csdn.net/Singleton1900/article/details/50435247 解决。 boolean 的序列化字段命名 public class Test {  private boolean isTest; public boolean isTest() {  return isTest;  } public void setTest(boolean isTest) {  this.isTest = isTest;  } } 这个类的对象在使用 JSON.toJSONString 方法时，isTest 字段名被改为了 test。 有几种方法可以解决：  将字段名改为 test（符合 Java Bean）   为字段名加上注解，标示它序列化的名字为 isTest   使用 Gson FastJson 项目里相关的讨论 Issue 如下： https://github.com/alibaba/fastjson/issues/278 ",
      "url"      : "https://blog.shcat.top/wiki/android-3rd-json/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "网络请求",
      "category" : "",
      "content": "Volley  Volley is not suitable for large download or streaming operations, since Volley holds all responses in memory during parsing. For large download operations, consider using an alternative like DownloadManager. Retrofit 打印日志 Retrofit 默认并没有将 request 和 response 的情况在 logcat 里打印出来，这不利于调试。打印日志需要使用到 OkHttp 的 LoggingInterceptor，关于 Interceptor 可以参见 OkHttp 的 Wiki。 示例代码： app/build.gradle ... dependencies {  ...  implementation 'com.squareup.okhttp3:logging-interceptor:3.9.1' } HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor(new HttpLoggingInterceptor.Logger() {  @Override  public void log(String message) {  LogUtils.d(retrofit, message);  } }); loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY); OkHttpClient client = new OkHttpClient.Builder()  .addInterceptor(loggingInterceptor)  .build(); Retrofit retrofit = new Retrofit.Builder()  .client(client)  .baseUrl(Constants.HTTP_BASE_URL)  .addConverterFactory(ScalarsConverterFactory.create())  .addConverterFactory(GsonConverterFactory.create())  .build(); LogginInterceptor 有 NONE、BASIC、HEADERS 和 BODY 四种 Level，按需求设置。 遇到错误 Case 1 android.util.MalformedJsonException: Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $ 一般是由于返回的 Json 串里有没用引号包围的字段名，比如 {name: Jack}。 方案有二：  修改服务端返回内容，确保该现象不会再发生；   修改客户端，让 GsonConverter 能够兼容处理这种情况，比如修改之前的代码是：  Retrofit retrofit = new Retrofit.Builder() .client(client) .baseUrl(Constants.HTTP_BASE_URL) .addConverterFactory(ScalarsConverterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .build();   修改之后：  Retrofit retrofit = new Retrofit.Builder() .client(client) .baseUrl(Constants.HTTP_BASE_URL) .addConverterFactory(ScalarsConverterFactory.create()) .addConverterFactory(GsonConverterFactory.create(new GsonBuilder().setLenient().create())) .build();   参考  Transmitting Network Data Using Volley ",
      "url"      : "https://blog.shcat.top/wiki/android-3rd-network/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "ORM",
      "category" : "",
      "content": "Room Google 官方出品。 优点：  使用注解，简化了一些使用 SQLite 需要手写的功能   编译时能做数据查询验证，提前报告错误，不用等到运行时，提升开发效率   内置数据迁移支持，相比 SQLite 的方法更清晰，解耦更好   Room 可以和 LiveData 集成，提供可观测数据库并感知生命周期的对象 greenDao ",
      "url"      : "https://blog.shcat.top/wiki/android-3rd-orm/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "动画",
      "category" : "",
      "content": "Property Animation Interpolator 功能：根据已流逝时间百分比计算出当前属性值改变百分比。 Android 提供的插值器：    Class/Interface  特性     AccelerateDecelerateInterpolator  先加速后减速（余弦曲线）    AccelerateInterpolator  加速    AnticipateInterpolator  先反向一段再正向加速    AnticipateOvershootInterpolator  先反向一段再正向加速超过最终值，最后回到最终值    BounceInterpolator  弹跳    CycleInterpolator  循环特定次数（正弦曲线）    DecelerateInterploator  减速    LinearInterpolator  线性    OvershootInterpolator  先超过最终值，最后回到最终值    TimeInterpolator  自定义插值器接口   Evaluator 功能：根据属性值改变百分比计算当前属性值。    Class/Interface  特性     IntEvaluator  计算 int 属性值的默认 evaluator    FloatEvaluator  计算 float 属性值的默认 evaluator    ArgbEvaluator  计算十六进制颜色属性值的默认 evaluator    TypeEvaluator  自定义 evaluator 的接口   参考  Property Animation ",
      "url"      : "https://blog.shcat.top/wiki/android-animation/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "架构模式",
      "category" : "",
      "content": "架构模式 MVC MVP MVVM Flux  https://facebook.github.io/flux/ http://androidflux.github.io/docs/overview.html The Clean Architecture 有价值的文章  Android架构思考(模块化、多进程) 参考  如何构建Android MVVM 应用框架 The Clean Architecture ",
      "url"      : "https://blog.shcat.top/wiki/android-arch-mode/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "体系结构",
      "category" : "",
      "content": "架构图 参考  The Android Source Code ",
      "url"      : "https://blog.shcat.top/wiki/android-arch/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "ART 与 Dalvik 的区别",
      "category" : "",
      "content": "Ahead-of-time(AOT) compilation ART 里引入了提前编译，在安装应用时采用更严格的校验机制，使用 dex2oat 工具将 dex 文件编译成本地代码保存到磁盘上。 而 Dalvik 主要使用 JIT，在运行时即时编译字节码为本地代码。 所以 ART 在安装时更耗时，更占用磁盘空间，但是运行更快。 改善了垃圾回收机制 部分 GC 过程可以并行执行，改善了内存碎片化的问题。 开发和调试方面的提升 支持更多的调试特性，比如可以直接看到当前存在哪些锁，哪些线程持有了这些锁；异常和崩溃报告里给出了更多的诊断信息。 参考  ART and Dalvik Android 5.0 行为变更 ",
      "url"      : "https://blog.shcat.top/wiki/android-art-and-dalvik/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "开机自启动",
      "category" : "",
      "content": "使用广播实现 AndroidManifest.xml &lt;uses-permission android:name=android.permission.RECEIVE_BOOT_COMPLETED /&gt; &lt;application  ... /&gt;  &lt;receiver android:name=.receiver.AutoBootReceiver&gt;  &lt;intent-filter&gt;   &lt;action android:name=android.intent.action.BOOT_COMPLETED /&gt;  &lt;/intent-filter&gt;  &lt;/receiver&gt; &lt;/application&gt; AutoBootReceiver.java public class AutoBootReceiver extends BroadcastReceiver {  @Override  public void onReceive(Context context, Intent intent) {  String action = intent.getAction();  if (TextUtils.isEmpty(action)) {   return;  }  if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {   LogUtils.i(receive boot_completed broadcast);   Intent i = new Intent(context, InitializeActivity.class);   i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);   context.startActivity(i);  }  } } ",
      "url"      : "https://blog.shcat.top/wiki/android-auto-boot/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "Activity",
      "category" : "",
      "content": "生命周期 生命周期回调 需要注意的点  如果有数据需要持久化，在 onPause() 的时候就做，因为 onStop() 返回之后 Activity 随时可能被杀死，而在 Pre-HONEYCOMB 版本里 onPause() 返回之后就可能被杀死。   onSaveInstanceState(Bundle) 的调用时机是 Activity 被杀掉之前，onStop() 之前，但因为它不是生命周期回调函数，所以并不能确保所有情况都能被调用到。 configChanges 要特别注意配置变化对生命周期的影响。 如果想屏幕方向变化时 Activity 不销毁重建，在 AndroidManifest.xml 里配置： &lt;activity  android:configChanges=keyboardHidden|orientation|screenSize|locale  ... 只配置一个 orientation 并不能生效，实际原因还需要好好探究一番，网上很多博客里说的配置了 configChanges 之后生命周期不会有变化，只是 onConfigurationChanged 会被调用到、keyboardHidden|orientation 会阻止生命周期销毁重建等都不准确。 参考：  https://developer.android.com/reference/android/app/Activity.html#ConfigurationChanges https://developer.android.com/reference/android/R.attr.html#configChanges Activity 的 LaunchMode  standard，标准模式，这也是默认模式。每次启动一个 Activity 都会重新创建一个新的实例。谁启动了这个 Activity，这个 Activity 就运行在启动它的那个 Activity 所在的栈中。   singleTop，栈顶复用模式。如果任务栈的栈顶是目标 Activity 的实例，那么将不会被创建新 Activity，同时栈顶 Activity 的 onNewIntent 会被调用。如果栈顶不是目标 Activity 的实例，则重新创建 Activity。   singleTask，栈内复用模式。是一种单例模式。如果栈内存在目标 Activity，那么多次重复启动不会创建新实例，默认具有 clearTop 效果。   singleInstance，单实例模式。加强的 singleTask，这个模式的 Activity 只能单独地位于一个任务栈中。 Activity 设计的好处  可以很方便地调起别的 Activity（包括应用内和应用外）并获取调用结果。这样即使两个 Activity 来自不同的应用，Activity A 调用 Activity B 处理完自己的 Intent，然后返回 Activity A，无缝切换，就像在同一个应用内一样。   不可见状态就停止活动，节约系统资源。   用栈管理，切换行为符合用户心理预期。 如何一次终止所有 Activity 可以使用 Intent.FLAG_ACTIVITY_CLEAR_TOP 调用栈底的 Activity，然后用一个标记让它 finish 自己。 Intent intent = new Intent(this, BottomActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); intent.putExtra(FINISH_ALL, true); startActivity(intent); 或者用一个自定义的比较土的思路： class BaseActivity extends Activity {  public static boolean sKillAll = false; @Override  protected void onResume() {   super.onResume();   if (sKillAll) {    finish();   }  } } 在想要终止所有 Activity 时，栈顶 Activity 将 BaseActivity.sKillAll 置为 true，然后 finish 自己。 Activity 实例泄漏 Activity 实例泄漏时（实例被长于它的对象持有），按 back 键时 onDestroy 仍会被调用到。回到它的实例是 GC 的事情，GC 和 Android 的生命周期方法回调是两回事。 ",
      "url"      : "https://blog.shcat.top/wiki/android-components-activity/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "BroadcastReceiver",
      "category" : "",
      "content": "一般情况下，onReceive 在 UI 线程执行，但也可以在 registerReceiver 时用 Handler 指定运行的线程。 Manifest-declared receivers 与 Context-registered receivers 的区别       Manifest-declared  Context-registered     注册时机  应用安装时  调用 registerReceiver 时    生命周期  onReceive 被调用期间有效  受注册时所用的 Context 生命周期影响   对进程状态的影响 在调用 onReceive 时，所在进程被当作 foreground process；onReceive 返回后，所在进程会被当作普通进程，如果进程里只有一个 manifest-declared receiver，它会被当作低优先级进程。 执行时间长一点的任务  使用 goAsync 结合 AsyncTask 等； 执行时间仍然不要超过 10 秒。   使用 JobScheduler 调度 JobService。 发送广播  sendOrderedBroadcast 发送有序广播，一次只有一个 receiver 接收到，接收的顺序由 intent-filter 的 android:priority 属性决定，相同优先级的则随机顺序接收；一个 receiver 接收到有序广播后可以选择中止传递，也可以继续传递，可以携带它处理的结果。   sendBroadcast 发送无序广播，可以同时发送给所有 receiver，这更高效，但无法得到其它 receiver 处理的结果。   LocalBroadcastManager.sendBroadcast 发送应用内广播。因为没有跨进程通信，这更高效更安全。 可以通过 Intent.setPackage 来限制发送广播给哪些应用。 权限 发送广播时添加权限，则只有已经被授予了对应权限的 receiver 可以接收到； 注册 receiver 时添加权限，则只有已经被授予了对应权限的应用可以发送广播给该 receiver。 安全考虑与最佳实践  如果只是应用内收发广播，使用 LocalBroadcastManager。   如果许多应用关注一个广播，那可能发出广播时造成许多应用启动，引起性能用用户体验的问题。这种情况下使用 context-registered receivers 会更好。比如 CONNECTIVEY_ACTION 广播只被分发给 context-registered receivers。   不要用隐式意图广播敏感信息。可以使用如下方法来限制接收者：    发送广播时指定权限；     在 Android 4.0 以上，可以使用 Intent.setPackage(String) 来限制接收的应用；     使用 local broadcasts。     可能有恶意广播来触发你的 receivers。可以使用如下方法来限制收到到的广播：    注册 receiver 时指定权限；     manifest-declared receivers 可以设置 android:exported 为 false 来屏蔽应用外的广播。     使用 local broadcasts。     broadcast 的 actions 命名空间是全局的，使用一个你独有的命名空间，像包名一样。   onReceive 一般运行在主线程，所以要迅速返回。如果想执行稍长时间的任务，慎重启动后台服务，因为在 onReceive 返回后整个进程的存活时间无法保证。建议的方法是：    在 onReceive 里调用 goAsync 然后将 BroadcastReceiver.PendingResult 传给后台线程，这将让该广播在 onReceive 返回后仍处于激活状态。这只是一个防止 UI 线程卡顿的方法，所有工作还是要在 10 秒内完成（普通 receiver 如果超过 10 秒还没返回会被系统认为阻塞了，会杀掉它）。     使用 JobScheduler。     不要在 onReceive 里启动 Activity，用户体验很差，特别是有多个 receiver 都这么干的时候。可以考虑使用 notification。  ",
      "url"      : "https://blog.shcat.top/wiki/android-components-broadcastreceiver/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "Fragment",
      "category" : "",
      "content": "生命周期  在 Fragment 从 BackStack 恢复时，Fragment 对象本身没有销毁，但它里面的 View 销毁重建了。 保存并恢复 View 的数据的最佳实践是让每个 View 都自己实现了 onSaveInstanceState/onRestoreInstanceState。 对于 ListView，其实在销毁重建 View 时调用 onCreateView 时，保存的 Fragment 实例里的 mAdapter 并没有销毁，所以可以直接使用里面保存的数据，不用再 new 一个。 参考：The Real Best Practices to Save/Restore Activity’s and Fragment’s state. 对应 Activity 状态的 Callbacks 遇到的问题 点击穿透 比如一个 Fragment 作为 DrawerLayout 里的 Drawer，点击这个 Fragment 没有控件的部分时，如果被覆盖的 Fragment 或者 Activity 上对应位置有按钮，点击事件会分发到这些按钮上去。 解决办法： 给 Fragment 的根 View 添加 clickable 属性，有两种实现方法，推荐第二种。  给所有需要解决此问题的 Fragment 的 Layout 文件的根结点添加 android:clickable=true。   所有 Fragment 继承自一个基类 BaseFragment，覆盖 BaseFragment 的 onViewCreated 方法（该方法会在 onCreateView 返回之后被调用），在该方法里用代码设置根 View 的 clickable 属性。  @Override public void onViewCreated(View view, Bundle savedInstanceState) { super.onViewCreated(view, savedInstanceState);  // 解决点击穿透的问题 view.setClickable(true); ...... }   replace 切换后恢复状态 使用 replace 方式切换 Fragment 后，又切换回来，此时 onCreateView 又会被调用到，如果重新 inflate layout，那界面状态会丢失，比如 Fragment 里有 WebView，那它的滚动位置等会丢失掉。 一种解决办法是在 onCreateView 里将 root view 保存下来，下次 onCreateView 被调用到时，判断 root 是否为空，为空就重新 inflate，不为空就直接复用： public class MyFragment extends Fragment { private View mRoot; @Nullable  @Override  public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {   if (mRoot != null) {    return mRoot;   } else {    // 重新 inflate layout，设置 View 和 data 等    // ...   }  } } ",
      "url"      : "https://blog.shcat.top/wiki/android-components-fragment/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "Intent",
      "category" : "",
      "content": "Intent 匹配 使用 PackageManager 返回能接受特定 Intent 的组件  queryIntentActivities()   queryIntentServices()   queryBroadcastReceivers() 判断是否有 Activity 能处理 Intent  Intent.resolveActivity()   Intent.resolveActivityInfo() 强制使用应用选择器 Intent sendIntent = new Intent(Intent.ACTION_SEND); ... // Always use string resources for UI text. // This says something like Share this photo with String title = getResources().getString(R.string.chooser_title); // Create intent to show the chooser dialog Intent chooser = Intent.createChooser(sendIntent, title); // Verify the original intent will resolve to at least one activity if (sendIntent.resolveActivity(getPackageManager()) != null) {  startActivity(chooser); } 点击链接启动其它应用 通过 Intent 实现，需要其它应用注册了对应的 intent-filter，包括 action、category 及 data（schema、host、pathPrefix）和 mimeType 等。 打开系统设置界面 android.provider.Settings类提供android系统各个页面的跳转常量，比如打开“开发者选项”页面： startActivity(new Intent(Settings.ACTION_APPLICATION_DEVELOPMENT_SETTINGS)); Action 列表（有可能需要配合包名类名打开）：    Action  功能  原文     ACTION_ACCESSIBILITY_SETTINGS  辅助功能模块的显示设置。  Activity Action: Show settings for accessibility modules.    ACTION_ADD_ACCOUNT  显示屏幕上创建一个新帐户添加帐户。  Activity Action: Show add account screen for creating a new account.    ACTION_AIRPLANE_MODE_SETTINGS  显示设置，以允许进入/退出飞行模式。  Activity Action: Show settings to allow entering/exiting airplane mode.    ACTION_APN_SETTINGS  显示设置，以允许配 置的APN。  Activity Action: Show settings to allow configuration of APNs.    ACTION_APPLICATION_DETAILS_SETTINGS  有关特定应用程序的详细信息的显示屏幕。  Activity Action: Show screen of details about a particular application.    ACTION_APPLICATION_DEVELOPMENT_SETTINGS  显示设置，以允许应用程序开发相关的设置配置  Activity Action: Show settings to allow configuration of application development-related settings.    ACTION_APPLICATION_SETTINGS  显示设置，以允许应用程序相关的设置配置  Activity Action: Show settings to allow configuration of application-related settings.    ACTION_BLUETOOTH_SETTINGS  显示设置，以允许蓝牙配置  Activity Action: Show settings to allow configuration of Bluetooth.    ACTION_DATA_ROAMING_SETTINGS  选择of2G/3G显示设置  Activity Action: Show settings for selection of2G/3G.    ACTION_DATE_SETTINGS  显示日期和时间设置，以允许配 置  Activity Action: Show settings to allow configuration of date and time.    ACTION_DEVICE_INFO_SETTINGS  显示一般的设备信息设置（序列号，软件版本，电话号码，等）  Activity Action: Show general device information settings (serial number, software version, phone number, etc.).    ACTION_DISPLAY_SETTINGS  显示设置，以允许配 置显示  Activity Action: Show settings to allow configuration of display.    ACTION_INPUT_METHOD_SETTINGS  特别配置的输入方法，允许用户启用输入法的显示设置  Activity Action: Show settings to configure input methods, in particular allowing the user to enable input methods.    ACTION_INPUT_METHOD_SUBTYPE_SETTINGS  显示设置来启用/禁用输入法亚型  Activity Action: Show settings to enable/disable input method subtypes.    ACTION_INTERNAL_STORAGE_SETTINGS  内部存储的显示设置  Activity Action: Show settings for internal storage.    ACTION_LOCALE_SETTINGS  显示设置，以允许配 置的语言环境  Activity Action: Show settings to allow configuration of locale.    ACTION_LOCATION_SOURCE_SETTINGS  显示设置，以允许当前位置源的配置  Activity Action: Show settings to allow configuration of current location sources.    ACTION_MANAGE_ALL_APPLICATIONS_SETTINGS  显示设置来管理所有的应用程序  Activity Action: Show settings to manage all applications.    ACTION_MANAGE_APPLICATIONS_SETTINGS  显示设置来管理安装的应用程序  Activity Action: Show settings to manage installed applications.    ACTION_MEMORY_CARD_SETTINGS  显示设置为存储卡存储  Activity Action: Show settings for memory card storage.    ACTION_NETWORK_OPERATOR_SETTINGS  选择网络运营商的显示设置  Activity Action: Show settings for selecting the network operator.    ACTION_PRIVACY_SETTINGS  显示设置，以允许配 置隐私选项  Activity Action: Show settings to allow configuration of privacy options.    ACTION_QUICK_LAUNCH_SETTINGS  显示设置，以允许快速启动快捷键的配置  Activity Action: Show settings to allow configuration of quick launch shortcuts.    ACTION_SEARCH_SETTINGS  全局搜索显示设置  Activity Action: Show settings for global search.    ACTION_SECURITY_SETTINGS  显示设置，以允许配 置的安全性和位置隐私  Activity Action: Show settings to allow configuration of security and location privacy.    ACTION_SETTINGS  显示系统设置  Activity Action: Show system settings.    ACTION_SOUND_SETTINGS  显示设置，以允许配 置声音和音量  Activity Action: Show settings to allow configuration of sound and volume.    ACTION_SYNC_SETTINGS  显示设置，以允许配 置同步设置  Activity Action: Show settings to allow configuration of sync settings.    ACTION_USER_DICTIONARY_SETTINGS  显示设置来管理用户输入字典  Activity Action: Show settings to manage the user input dictionary.    ACTION_WIFI_IP_SETTINGS  显示设置，以允许配 置一个静态IP地址的Wi – Fi  Activity Action: Show settings to allow configuration of a static IP address for Wi-Fi.    ACTION_WIFI_SETTINGS  显示设置，以允许Wi – Fi配置  Activity Action: Show settings to allow configuration of Wi-Fi.    ACTION_WIRELESS_SETTINGS  显示设置，以允许配 置，如Wi – Fi，蓝牙和移动网络的无线控制  Activity Action: Show settings to allow configuration of wireless controls such as Wi-Fi, Bluetooth and Mobile networks.    AUTHORITY          EXTRA_AUTHORITIES  在推出活动的基础上给予的权力限制可选项。  Activity Extra: Limit available options in launched activity based on the given authority.    EXTRA_INPUT_METHOD_ID         参考  Intent 和 Intent 过滤器 android 打开系统设置界面 ",
      "url"      : "https://blog.shcat.top/wiki/android-components-intent/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "Service",
      "category" : "",
      "content": "生命周期 要点  服务在其托管进程的主线程中运行，它既不创建自己的线程，也不在单独的进程中运行（除非另行指定）。   两种调用方式：startService() 和 bindService()。   startService() 与 bindService() 有可能都被调用，那样除非所有客户端均取消绑定（组件销毁或 unbindService()），且调用过 stopService() 或 stopSelf() 后才会实际停止服务。   多次服务启动请求会导致多次对服务的 onStartCommand() 进行相应的调用。但是，要停止服务，只需一个服务停止请求（使用 stopSelf() 和 stopService()）即可。 如何让 Service 不被杀死  将服务绑定到具有用户焦点的 Activity；   将服务声明为在前台运行；   onStartCommand() 返回 START_STICKY 或 START_REDELIVER_INTENT；   注册一些系统广播事件拉活服务；   Native 守护进程或 Service 守护，轮询状态，检测到进程结束就启动；   两个分别运行在独立进程里的 Service，相互绑定，在一个服务被杀死后，另一个会被调用到 onServiceDisconnected，在里面调用 startService 和 bindService 启动对方。 参考       [Services   Android Developers](https://developer.android.com/guide/components/services.html)     ",
      "url"      : "https://blog.shcat.top/wiki/android-components-service/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "Context",
      "category" : "",
      "content": "Context 类结构图 （最常见的部分类） Context 的用途 Activity、Service 和 BroadcastReceiver 等类并不像普通的 Java 对象 new 一个实例就能正常使用了，而是要有它们各自的上下文环境，即 Context。 它可以用于弹出 Toast、启动 Activity、启动 Service、发送广播、操作数据库等。 Context 的分类 由文首的图可知，Context 分为 Activity、Service 和 Application 三类。 一般情况下它们可以通用，例外情况：  启动 Activity 时，因为 Activity 需要有任务栈，一般需要 Activity 类型的 Context，如果使用 Application 或 Service 类型的 Context，需要 FLAG_ACTIVITY_NEW_TASK。  android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag.   Dialog 必须在 Activity 上面弹出（除非是 System Alert 类型），此时只能使用 Activity 类型的 Context。   Layout Inflation 推荐使用 Activity 类型的 Context。 如下图：    Context 类型  Application  Activity  Service     Show a Dialog  No  Yes  No    Start an Activity  不推荐  Yes  不推荐    Layout Inflation  不推荐  Yes  不推荐    Start a Service  Yes  Yes  Yes    Send a Broadcast  Yes  Yes  Yes    Register Broadcast Receiver  Yes  Yes  Yes    Load Resource Values  Yes  Yes  Yes   与 UI 相关的应优先使用 Activity 类型的 Context 处理，其它可通用。 防止内存泄漏  在 Application 类型 Context 满足需求的情况下，优先使用它。   不要让生命周期长于 Activity 的对象持有 Activity 的引用。   尽量不要在 Activity 中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。 参考  Android Context完全解析，你所不知道的Context的各种细节 Context都没弄明白，还怎么做Android开发？ ",
      "url"      : "https://blog.shcat.top/wiki/android-context/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "事件分发机制",
      "category" : "",
      "content": "MotionEvent 的传递规则 主要涉及到三个方法：  public boolean dispatchTouchEvent(MotionEvent ev) 用来进行事件的分发。如果事件能够传递给当前 View，那么它一定会被调用，返回值表示是否消耗当前事件。   public boolean onInterceptTouchEvent(MotionEvent ev) 判断是否拦截某个事件。如果当前 View 拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回值表示是否拦截当前事件。   public boolean onTouchEvent(MotionEvent ev) 处理点击事件，返回值表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前 View 无法再次接收到事件。 根据《Android 开发艺术探索》里的描述和我自己对源码的解读，可以用下面这样一段伪代码来表示事件分发机制： public boolean dispatchTouchEvent(MotionEvent ev) {  boolean consume = false;  if (onInterceptTouchEvent(ev)) {  if (mOnTouchListener != null) {   consume = mOnTouchListener.onTouch(this, ev);  }  if (!consume) {   consume = onTouchEvent(ev); // may call OnClickListener.onClick  }  } else {  for (View child: mChildren) {   if (consume = child.dispatchTouchEvent(ev)) {    break;   }  }  } if (!consume) {  consume = super.dispatchTouchEvent(ev);  } return consume; } 事件总是按 Activity -&gt; Window -&gt; View 由自顶向下分发，下层不消耗则交回上层，直到得到处理为止。 关于事件传递机制的一些结论：  同一事件序列是指从手指接触屏幕那一刻起，到手指离开屏幕的那一刻结束，在这个过程中所产生的一系列事件，这个事件序列以 down 事件开始，中间含有数量不定的 move 事件，最终以 up 事件结束。   正常情况下，一个事件序列只能被一个 View 拦截且消耗。这一条的原因可以参考 3，因为一旦一个元素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个 View 同时处理，但是通过特殊手段可以做到，比如一个 View 将本该自己处理的事件通过 onTouchEvent 强行传递给其它 View 处理。   某个 View 一旦决定拦截，那么这一事件序列都只能由它来处理（如果事件序列能够传递给它的话），并且它的 onInterceptTouchEvent 不会再被调用（系统直接把同一事件序列内的事件都交给它处理，不再通过 onInterceptTouchEvent 询问它是否要拦截）。   某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件（onTouchEvent 返回了 false），那么同一事件序列中的其它事件都不会再交给它来处理，并且事件将重新交由它的父元素去处理，即父元素的 onTouchEvent 会被调用。   如果 View 不消耗除 ACTION_DOWN 以外的其它事件，那么这个点击事件会消失，此时父元素的 onTouchEvent 并不会被调用，并且当前 View 可以持续收到后续的事件，最终这些消失的点击事件会传递给 Activity 处理。   ViewGroup 默认不拦截任何事件。Android 源码中 ViewGroup 的 onInterceptTouchEvent 方法默认返回 false。   View 没有 onInterceptTouchEvent 方法，一旦有点击事件传递给它，它的 onTouchEvent 方法就会被调用。   View 的 onTouchEvent 默认返回 true，除非它是不可点击的（clickable 和 longClickable 同时为 false）。View 的 longClickable 属性默认都为 false，clickable 要分情况，比如 Button 的 clickable 属性默认为 true，而 TextView 的默认为 false。   View 的 enable 属性不影响 onTouchEvent 的默认返回值。哪怕一个 View 是 disable 状态的，只要它的 clickable 或者 longClickable 有一个为 true，那么它的 onTouchEvent 就返回 true。   onClick 会发生的前提是当前 View 是可点击的，并且它收到了 down 和 up 事件。   事件传递过程是由外向内的，即事件总是先到达父元素，然后再由父元素分发给子 View，通过 requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的事件颁发过程，但是 ACTION_DOWN 事件除外。 参考  《Android 开发艺术探索》 ",
      "url"      : "https://blog.shcat.top/wiki/android-event-dispatch/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "进程间通信",
      "category" : "",
      "content": "进程间通信方式    名称  优点  缺点  适用场景     Intent  简单易用  只能传输 Bundle 支持的数据类型  四大组件间的进程间通信    文件共享  简单易用  不适合高并发场景，并且无法做到进程间的即时通信  无并发访问，交换简单的数据，实时性不高的场景    AIDL  功能强大，支持一对多并发通信，支持实时通信  使用稍复杂，需要处理好线程同步  一对多通信且有 RPC 需求    Messenger  功能一般，支持一对多串行通信，支持实时通信  不能很好处理高并发情形，不支持 RPC，数据通过 Message 进行传输，因此只能传输 Bundler 支持的数据类型  低并发的一对多即时通信，无 PRC 需求，或者无需要返回结果的 RPC 需求    ContentProvider  在数据源访问方面功能强大，支持一对多并发数据共享，可通过 ContentProvider 和 ContentResolver 的 Call 方法扩展其它操作  可能理解为受约束的 AIDL，主要提供数据源的 CRUD 操作  一对多的进程间的数据共享    Socket  功能强大，可以通过网络传输字节流，支持一对多并发实时通信  实现细节略繁琐，不支持直接的 RPC  网络数据交换   参考  《Android 开发艺术探索》 ",
      "url"      : "https://blog.shcat.top/wiki/android-ipc/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "消息机制",
      "category" : "",
      "content": "在工作线程里如何也能处理消息 方法一： 给线程关联一个 Looper.prepare()，然后调用 Looper.loop()。 方法二： 使用 HandlerThread。 ",
      "url"      : "https://blog.shcat.top/wiki/android-messages/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "Android 开发技术概述",
      "category" : "",
      "content": "每项的简单说明待补充。 常用架构 MVC MVP MVVM The Clean Architechture 开发工具 开发环境 Android Studio Eclipse (Deprecated) 反编译工具 jadx apktool jd-gui dex2jar 常用第三方组件包 网络库 Retrofit OkHttp Volley 数据库组件 greenDao OrmLite Room Realm 图片库 Glide Fresco Picasso Json 序列化与反序列化 Gson FastJson 注解库 ButterKnife Dagger 2 函数响应式编程 RxJava RxAndroid 事件总线 EventBus 条形码二维码 zxing 热修复 tinker dexposed 插件化 DroidPlugin atlas Small dynamic-load-apk 综合快速开发框架 xUtils 3 混合开发框架 React Native Weex ",
      "url"      : "https://blog.shcat.top/wiki/android-overview/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "插件化",
      "category" : "",
      "content": "方案  DroidPlugin 项目里的学习资料写得很好。   Small   dynamic-load-apk 参考  Android 开发中的日常积累 ",
      "url"      : "https://blog.shcat.top/wiki/android-plugin/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "坐标系",
      "category" : "",
      "content": "View 与 MotionEvent 的主要坐标系参考值： x、y 和 translationX、translationY 是对于移动过程有用的概念。  x = left + translationX   y = top + translationY  ",
      "url"      : "https://blog.shcat.top/wiki/android-position/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "Android 逆向工程",
      "category" : "",
      "content": "Content here ",
      "url"      : "https://blog.shcat.top/wiki/android-reverse-engineering/",
      "keywords" : "keyword1, keyword2"
    } ,
  
    {
      "title"    : "屏幕适配",
      "category" : "",
      "content": "主要方法  在 xml 文件里使用 @dimen/xxx 引用尺寸数值，针对不同分辨率提供多套 dimens 文件，尽量使用 dp/sp。   利用 weight 进行百分比适配。   使用 com.android.support:percent 库里的 PercentRelativeLayout 和 PercentFrameLayout 等。   参考张鸿洋的一种实现思路（也是想实现百分比）： 根据给定设计图的基准分辨率，将屏幕按分辨率纵横等分成多少份，计算出所有需要支持的分辨率里 n 份对应的像素值，然后写到对应的 dimens 文件里，编写 xml 时使用 @dimen/xn 这种写法。 参考：Android 屏幕适配方案 可考虑采用的配合措施  在代码里动态计算和调整。   多套布局文件进行适配。   使用 nine-patch 图。  ",
      "url"      : "https://blog.shcat.top/wiki/android-screen-support/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "软键盘",
      "category" : "",
      "content": "常用方法 InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); // 获取软键盘的显示状态 boolean isOpen=imm.isActive(); // 如果软键盘已经显示，则隐藏，反之则显示 imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS); // 隐藏软键盘 imm.hideSoftInputFromWindow(view, InputMethodManager.HIDE_NOT_ALWAYS); // 强制显示软键盘 imm.showSoftInput(view,InputMethodManager.SHOW_FORCED);  // 强制隐藏软键盘 imm.hideSoftInputFromWindow(view.getWindowToken(), 0); 参考：Android : 隐藏软键盘 Activity 展示时控制软键盘 AndroidManifest.xml &lt;activity android:name=.TestActivity  android:windowSoftInputMode=stateHidden|adustUnspecified /&gt; &lt;activity android:name=.DemoActivity  android:windowSoftInputMode=stateAlwaysVisible /&gt; 参考：  Handle input method visibility manifest/activity-element ",
      "url"      : "https://blog.shcat.top/wiki/android-softinput/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "Android Studio",
      "category" : "",
      "content": "本文主要记录 Android Studio 的使用技巧等，使用过程中遇到的问题详见我的另一篇博客 Android Studio 遇到问题集锦。 快捷键 C –&gt; Ctrl S –&gt; Shift M –&gt; Alt Cmd –&gt; Command 导航与跳转    功能  快捷键 for win  快捷键 for mac     Find Action  C-S-a  Cmd-S-a    最近使用的文件  C-e  Cmd-e    Outline  C-F12  Cmd-F12    定位到导航条  M-Home  Cmd-Up    快速打开类定义  C-n  Cmd-n    跳转至指定符号  C-S-M-n  Cmd-S-M-n    快速打开文件  C-S-n  Cmd-S-o    在…中选定当前文件  M-F1  M-F1    最近编辑过的文件  C-S-e  Cmd-S-e    打开光标所在变量类定义  C-S-b  Cmd-S-b    跳到变量/函数/类定义  C-b/鼠标左键  Cmd-b/鼠标左键/Down    导航 Back/Forward  C-M-Left/Right  Cmd-[/]    Super Method  C-u  Cmd-u    Implementations  C-M-b  Cmd-M-b    Method Hierarchy  C-S-h  Cmd-S-h    Type Hierarchy  C-h  C-h    Call Hierarchy  C-M-h  C-M-h    Find Usages  M-F7  M-F7    Show Usages  C-M-F7  Cmd-M-F7    搜索 Everywhere  双击 S  双击 S    搜索文本  C-S-f  Cmd-S-f    打开文件所在目录  M-F1 8  M-F1 8    打开设置  C-M-s  Cmd-,   切换至指定的工具窗口    功能  快捷键 for win  快捷键 for mac     Project  M-1  Cmd-1    Terminal  M-F12  M-F12    Editor  Esc  Esc   编辑    功能  快捷键 for win  快捷键 for mac     注释/取消注释（//）  C-/  Cmd-/    注释/取消注释（/**/）  C-S-/  C-S-/    格式化代码  C-M-l  Cmd-M-l    智能 Import  C-M-o  C-M-o    Undo  C-z  Cmd-z    Redo  C-S-z  Cmd-S-z    删除行  C-y  Cmd-x    复制行  C-c  Cmd-c    复制当前行到下一行  C-d  Cmd-d    在下面另起一行  S-Enter  S-Enter    在上面另起一行  C-M-Enter  Cmd-M-Enter    上/下移动代码行  M-S-Up/Down  M-S-Up/Down    上/下一处引用  C-M-Up/Down  Cmd-M-Up/Down    关闭浮动窗口  S-Esc  S-Esc    单步  F8  F8    步入  F7  F7    继续执行  F9  Cmd-M-r    执行直到返回  S-F8  S-F8    执行到光标处  M-F9  M-F9    运行当前应用  S-F10  C-r    调试当前应用  S-F9  C-d    开/关断点  C-F8/鼠标左键  Cmd-F8    查看所有断点  C-S-F8  Cmd-S-F8    自动生成  M-Insert  Cmd-n    隐藏底部视图  S-Esc  S-Esc    删除一个单词  C-Backspace  M-delete    重构 - 重命名  S-F6  S-F6   注：  在 Windows 下格式化代码的 Ctrl+Alt+l 和 QQ 锁热键冲突了，我去 QQ 的设置里删除了QQ 锁热键。 在 Windows 下打开 Settings 的 Ctrl+Alt+s 与 QQ 打开消息盒子热键冲突了，我删除了 QQ 里的该热键。 折叠    功能  快捷键 for win  快捷键 for mac     折叠当前代码块  C-S-.       展开当前代码块  鼠标左键       折叠当前折叠区域  C–       展示当前折叠区域  C-+      小技巧 快速在 Activity/Fragment 与 Layout 文件之间跳转 在 Activity/Fragment 里点击类名前的小图标跳转到关联的 Layout XML 文件： 在 Layout XML 文件里点击根节点前的小图标跳转到关联的 Activity/Fragment： 插件  android-styler Android Studio / IDEA plugin that helps to create styles   Alibaba Java Coding Guidelines 阿里巴巴 Java 代码规范检测插件   Android Parcelable Code Generator 一键自动生成 Parcelable 代码   Lombok Plugin Lombok 注解支持   GsonFormat 根据 Gson 库使用的要求，根据 Json 数据生成 Java 实体   intellij-javadocs 自动生成/删除指定区域或文件的 javadoc。 打包  Gradle编译打包小结 Gradle构建Android项目 设置 此部分与 Intellj IDEA 通用。 在工程视图里隐藏指定类型文件 比如要隐藏 Vim 打开文件产生的 *.swp 文件，操作步骤：  在 Android Studio 里打开 File - Settings - Editor - File Types；   在 Ignore files and folders 里加上 *.swp，点 OK 保存。 屏蔽 IDE 的某些弹出通知 有些 IDE 通知经常弹出，而你却并不想看到它，比如 Usage Statistics，Vcs Notifications 等，屏蔽步骤：  在 Android Studio 里打开 File - Settings - Appearance &amp; Behavior - Notifications；   在界面上找到你想屏蔽的 Group，将 Popup 列改为 No popup，点 OK 保存即可。 定制自动生成的 Getter、Setter 默认行为下，如果一个类有成员变量 mUser，那么生成的 Getter/Setter 的名字会叫做 getmUser 和 setmUser，但我期望的是 getUser 和 setUser，这可以通过修改设置来实现：  在 Android Studio 里打开 File - Settings - Editor - Code Style - Java   在右侧找到 Code Generation 这个 tab，在 Naming 的 Prefer longer names 里，field 的 Name prefix 里填上 m，Static field 的 Name prefix 里填上 s。  设置 logcat 缓冲区条数 logcat 默认缓冲区条数不大，在日志比较多的时候经常出现想要的信息被冲掉的情况，所以一般都将缓冲区条数设置大一些，方法：  关闭 Android Studio；   给 Android Studio 安装目录下的 bin/idea.properties 文件添加如下内容： idea.cycle.buffer.size=1024000   这个数字可以根据需求修改。   启动 Android Studio。 设置生成注释时的 author 默认情况下文件头注释里的 author 是当前登录操作系统的用户名，如 Administrator 或 Lenovo 等，如果我们想替换成自己的名字，方法是打开 Android Studio 可执行程序，比如 studio64.exe 同目录下的 studio64.exe.vmoptions，在最下面加入这样一行： -Duser.name=mazhuang 然后重新启动 Android Studio 即可。 此方法同样适用于 IntelliJ Idea，修改 idea64.exe.vmoptions 即可。 修改新建 Activity 的默认布局 现在新建 Activity 等，layout 文件里的默认布局为 ConstraintLayout，这个布局被吹得神乎其技，但我还没有用惯……所以希望新建 Activity 的默认布局改为 RelativeLayout。 在 StackOverflow 上搜索到解决方案： 链接：How to switch from the default ConstraintLayout to RelativeLayout in Android Studio 简述：  找到 Android Studio 安装目录，打开子目录 plugins/android/lib/templates/activities/common/root/res/layout，在下面应该能看到 simple.xml.ftl 文件，这就是我们新建 Activity 时的 layout 模板了；   备份 simple.xml.ftl 文件；   打开 simple.xml.ftl 文件，可以看到如下内容：  &lt;?xml version=1.0 encoding=utf-8?&gt; &lt;android.support.constraint.ConstraintLayout xmlns:android=http://schemas.android.com/apk/res/android xmlns:tools=http://schemas.android.com/tools xmlns:app=http://schemas.android.com/apk/res-auto android:layout_width=match_parent android:layout_height=match_parent &lt;#if hasAppBar &amp;&amp; appBarLayoutName??&gt; app:layout_behavior=@string/appbar_scrolling_view_behavior tools:showIn=@layout/${appBarLayoutName} &lt;/#if&gt; tools:context=${packageName}.${activityClass}&gt; &lt;#if isNewProject!false&gt; &lt;TextView &lt;#if includeCppSupport!false&gt;  android:id=@+id/sample_text &lt;/#if&gt;  android:layout_width=wrap_content  android:layout_height=wrap_content  android:text=Hello World!  app:layout_constraintBottom_toBottomOf=parent  app:layout_constraintLeft_toLeftOf=parent  app:layout_constraintRight_toRightOf=parent  app:layout_constraintTop_toTopOf=parent /&gt; &lt;/#if&gt; &lt;/android.support.constraint.ConstraintLayout&gt;   将这些内容修改为：  &lt;?xml version=1.0 encoding=utf-8 &lt;RelativeLayout xmlns:android=http://schemas.android.com/apk/res/android xmlns:tools=http://schemas.android.com/tools android:layout_width=match_parent android:layout_height=match_parent &gt; &lt;/RelativeLayout&gt;   重启 Android Studio。 同理，如果要修改新创建的 BlankFragment、ListFragment 等的默认布局，可以在 Android Studio 安装目录下的 plugins/android/lib/templates/other 下找到对应的模板内容并修改。 这样修改之后，会导致一个问题，就是 Android Studio 升级会失败，提示： Some conflicts were found in the installation area. Some on the conficts below do not have a solution, so the patch cannot be applied. Press Cancel to exit.   File  Action  Problem  Solution     plugins/android/lib/templates/activities/common/root/res/layout/simple.xml.ftl  Validate  Modified  NONE   解决方案： 将备份的文件贴回去，然后等 Android Studio 升级完成之后再改成我们想要的版本即可。 安装 Android Studio 后不显示 logcat 窗口 新建或打开一个简单的 Android 工程，编译运行后，窗口就会自动出来了。 其它信息 Android Plugin 与 Gradle 版本对应 https://developer.android.com/studio/releases/gradle-plugin.html ",
      "url"      : "https://blog.shcat.top/wiki/android-studio/",
      "keywords" : "Android, Android Studio"
    } ,
  
    {
      "title"    : "Awesome Adb",
      "category" : "",
      "content": "Content here ",
      "url"      : "https://blog.shcat.top/wiki/android-tools-adb/",
      "keywords" : "adb, Andriod Debug Bridge"
    } ,
  
    {
      "title"    : "构建和签名",
      "category" : "",
      "content": "构建相关问题 65K 方法数限制 简而言之： 编译器生成 classes.dex 文件时会给一个 dex 文件里的所有方法分配一个唯一 ID，而这个 ID 限于 Dalvik bytecode 操作数 16 bits 的限制，范围为 [0, 0xffff]。 在代码里区分 Debug 和 Release 使用 BuildConfig.DEBUG 并不总是准确，有几种方法来较为准确地区分当前是 Debug 版还是 Release 版，都是需要用 Gradle 脚本做一些配置。 方法一： 在 App 或者 Module 的 build.gradle 里添加配置： gradle.startParameter.getTaskNames().each { task -&gt;  println(task: + task)  // library里 BuildConfig.DEBUG 默认一直是 flase 所以需要自定义  if (task.contains(Debug)) {  android {   defaultPublishConfig debug  } } else if (task.contains(Release)) {  android {   defaultPublishConfig release  }  } } 然后在代码里使用 BuildConfig.DEBUG 就准确了。 方法二： buildTypes {  debug {  resValue string, build_config_type, debug  }  release {  resValue string, build_config_type, release  } } 然后在代码里使用 context.getString(R.string.build_config_type) 值是否为 debug 来判断。 打包时分开生成 32 位和 64 位包 通过 splits.abi 配置来实现。 配置了 split.abi 后，defaultConfig.ndk.apiFilters 需要注释掉。 android {  splits {  abi {   enable true   reset()   include 'armeabi-v7a', 'arm64-v8a'  }  } } 详细配置可参考官方文档：https://developer.android.google.cn/studio/build/configure-apk-splits.html#configure-abi-split 签名 命令行给 apk 签名 使用 jarsigner，具体的参数含义可以参考 jarsigner 命令的帮助提示。 jarsigner -verbose -keystore xxx.jks -signedjar signed.apk unsigned.apk [别名] 参考  由Android 65K方法数限制引发的思考 解决传说中的 Android 65k 问题 Android如何区分debug和release两种状态 Android打包的那些事 ",
      "url"      : "https://blog.shcat.top/wiki/android-tools-build/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "更新 UI",
      "category" : "",
      "content": "一般要求在 UI 线程中更新 UI，但在子线程中直接操作 UI 也并非不可能，比如在 ViewRootImpl 初始化（Activity 的 onResume 里）之前，操作 UI 不会调用到 ViewRootImpl 的 checkThread。 在子线程中操作 UI 的方法  通过 handler。   Activity 的 runOnUiThread 方法。   View 的 post / postDelayed / postOnAnimation / postOnAnimationDelayed 方法，可以传一个 Runnable（可能还有一个 delayMillis）作为参数。  ",
      "url"      : "https://blog.shcat.top/wiki/android-update-ui/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "Button",
      "category" : "",
      "content": "自定义外观 自绘圆形背景 layout/xxx.xml &lt;Button  ...  android:background=@drawable/button_background /&gt; drawable/button_background.xml &lt;?xml version=1.0 encoding=utf-8?&gt; &lt;selector xmlns:android=http://schemas.android.com/apk/res/android&gt;  &lt;item android:state_pressed=true android:drawable=@drawable/shape_corners_pressed /&gt;  &lt;item android:drawable=@drawable/shape_corners /&gt; &lt;/selector&gt; drawable/shape_corners_pressed.xml &lt;?xml version=1.0 encoding=utf-8?&gt; &lt;shape xmlns:android=http://schemas.android.com/apk/res/android&gt;  &lt;corners android:radius=20dp/&gt;  &lt;solid android:color=#22ffffff /&gt;  &lt;stroke android:color=@android:color/white android:width=1dp /&gt; &lt;/shape&gt; drawable/shape_corners.xml &lt;?xml version=1.0 encoding=utf-8?&gt; &lt;shape xmlns:android=http://schemas.android.com/apk/res/android&gt;  &lt;corners android:radius=20dp/&gt;  &lt;stroke android:color=@android:color/white android:width=1dp /&gt; &lt;/shape&gt; 去掉自带阴影 默认的按钮是带阴影的，可以通过设置 style=?android:attr/borderlessButtonStyle 解决。 参考：https://developer.android.com/guide/topics/ui/controls/button.html#Borderless ",
      "url"      : "https://blog.shcat.top/wiki/android-view-button/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "CheckBox",
      "category" : "",
      "content": "UI 定制 修改 check 与 unchecked 图片 layout/layout_xxx.xml &lt;CheckBox  ...  android:button=@drawable/check_selector  ... /&gt; 修改文字与选择框距离 android:paddingLeft=10dp ",
      "url"      : "https://blog.shcat.top/wiki/android-view-checkbox/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "Dialog",
      "category" : "",
      "content": "AlertDialog 创建一个只有进度条的对话框 xxx.java AlertDialog.Builder builder = new AlertDialog.Builder(context)  .setView(R.layout.window_loading)  .setCancelable(false); // 对话框外点击无法退出 dialog = builder.create(); Window window = dialog.getWindow(); if (window != null) {  // 设置背景透明  window.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); } dialog.show(); layout/window_loading.xml &lt;?xml version=1.0 encoding=utf-8?&gt; &lt;ProgressBar xmlns:android=http://schemas.android.com/apk/res/android  style=?android:attr/progressBarStyleLarge  android:layout_width=match_parent  android:layout_height=match_parent  android:indeterminate=true /&gt; 修改按钮的文字颜色 values/styles.xml &lt;style name=AppTheme parent=Theme.AppCompat.Light.DarkActionBar&gt;  &lt;!-- ... --&gt;  &lt;item name=buttonBarPositiveButtonStyle&gt;@style/positiveButtonStyle&lt;/item&gt;  &lt;item name=buttonBarNegativeButtonStyle&gt;@style/negativeButtonStyle&lt;/item&gt; &lt;/style&gt; &lt;style name=positiveButtonStyle parent=Base.Widget.AppCompat.Button.ButtonBar.AlertDialog&gt;  &lt;item name=android:textColor&gt;@color/zkhRed&lt;/item&gt; &lt;/style&gt; &lt;style name=negativeButtonStyle parent=Base.Widget.AppCompat.Button.ButtonBar.AlertDialog&gt;  &lt;item name=android:textColor&gt;@color/textNormal&lt;/item&gt; &lt;/style&gt; 参考：Android-用style修改AlertDialog修改按钮文字颜色 显示富文本 values/strings.xml &lt;string name=test_string&gt;&lt;![CDATA[中间是&lt;font color=  '#ff0000  '&gt;红字&lt;/font&gt;哈]]&gt;&lt;/string&gt; xx.java new AlertDialog.Builder()  .setMessage(Html.fromHtml(getString(R.string.test_string)))  ... ",
      "url"      : "https://blog.shcat.top/wiki/android-view-dialog/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "EditText",
      "category" : "",
      "content": "常见问题及解决方案 限制为单行 android:inputType=text 更改背景为底部一条线 drawable/edittext_background.xml &lt;?xml version=1.0 encoding=utf-8?&gt; &lt;selector xmlns:android=http://schemas.android.com/apk/res/android&gt;  &lt;item android:state_focused=true android:drawable=@drawable/edittext_focused /&gt;  &lt;item android:drawable=@drawable/edittext_normal /&gt; &lt;/selector&gt; drawable/edittext_normal.xml &lt;?xml version=1.0 encoding=utf-8?&gt; &lt;layer-list xmlns:android=http://schemas.android.com/apk/res/android&gt;  &lt;item  android:left=-1dp  android:right=-1dp  android:top=-1dp&gt;  &lt;shape&gt;   &lt;solid android:color=#00FFFFFF /&gt;   &lt;stroke    android:width=1dp    android:color=#FFFFFF /&gt;  &lt;/shape&gt;  &lt;/item&gt; &lt;/layer-list&gt; drawable/edittext_focused.xml &lt;?xml version=1.0 encoding=utf-8?&gt; &lt;layer-list xmlns:android=http://schemas.android.com/apk/res/android&gt;  &lt;item  android:left=-1dp  android:right=-1dp  android:top=-1dp&gt;  &lt;shape&gt;   &lt;solid android:color=#00FFFFFF /&gt;   &lt;stroke    android:width=1dp    android:color=@android:color/holo_green_dark /&gt;  &lt;/shape&gt;  &lt;/item&gt; &lt;/layer-list&gt; 更换光标颜色 layout/xxx.xml &lt;EditText  ...  android:textCursorDrawable=@drawable/edittext_cursor /&gt; drawable/edittext_cursor.xml &lt;?xml version=1.0 encoding=utf-8?&gt; &lt;shape xmlns:android=http://schemas.android.com/apk/res/android&gt;  &lt;size android:width=1dp /&gt;  &lt;solid android:color=@android:color/holo_green_dark /&gt; &lt;/shape&gt; 解决获取到焦点后光标自动跳到最前面的问题 editText.setText(content); editText.setSelection(content.length()); 限制只能输入数字，最大长度为 9 位 &lt;EditText  ...  android:inputType=number  android:digits=0123456789  android:maxLength=9  ... /&gt; 限制只能输入 IP 地址 EditText ipEditText = (EditText) root.findViewById(R.id.ip_address); InputFilter[] filters = new InputFilter[1]; filters[0] = new InputFilter() {  @Override  public CharSequence filter(CharSequence source, int start,      int end, Spanned dest, int dstart, int dend) {  if (end &gt; start) {   String destTxt = dest.toString();   String resultingTxt = destTxt.substring(0, dstart) +    source.subSequence(start, end) +    destTxt.substring(dend);   if (!resultingTxt.matches (^    d{1,3}(    . +    (    d{1,3}(    .(    d{1,3}(    .(    d{1,3})?)?)?)?)?)?)) {    return ;   } else {    String[] splits = resultingTxt.split(    .);    for (int i=0; i&lt;splits.length; i++) {    if (Integer.valueOf(splits[i]) &gt; 255) {     return ;    }    }   }  }  return null;  } }; ipEditText.setFilters(filters); 顺便给一个校验 IP 地址是否有效的工具方法： public static boolean isIpAddress(String text) {  Pattern p = Pattern.compile(^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)    .){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$);  Matcher m = p.matcher(text);  return m.find(); } 显示隐藏密码 if (show) {  // 显示  mPasswordEditText.setTransformationMethod(HideReturnsTransformationMethod.getInstance()); } else {  // 隐藏  mPasswordEditText.setTransformationMethod(PasswordTransformationMethod.getInstance()); } setInputType 的方法在我尝试的过程中有点问题，表现与预期不一致。 imeOptions 举个例子，让软件键盘的回车键变成“搜索”，并且点击的时候执行某特定动作： &lt;EditText  ...  android:imeOptions=actionSearch  android:inputType=text /&gt; editText.setOnEditorActionListener(new TextView.OnEditorActionListener() {  @Override  public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {  if ((event != null) &amp;&amp; event.getKeyCode() == KeyEvent.KEYCODE_ENTER &amp;&amp; event.getAction() == KeyEvent.ACTION_DOWN) {   onSearch();   return true;  } else if (actionId == EditorInfo.IME_ACTION_SEARCH) {   onSearch();   return true;  }  return false;  } }); imeOptions 还可以对应一些其它的值，详见 https://developer.android.com/reference/android/widget/TextView.html#attr_android:imeOptions ",
      "url"      : "https://blog.shcat.top/wiki/android-view-edittext/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "ImageView",
      "category" : "",
      "content": "src 与 background 的区别  图片拉伸 background 会根据 ImageView 的长宽进行拉伸，src 默认使用原图大小，但可使用 scaleType 指定填充方式。   设置透明度 ImageView.setAlpha() 时调整的是 src 的透明度。 scaleType    值  含义     matrix       fitXY  不按比例拉伸填满 View    fitStart  按比例缩放至图片的宽高均小于等于 View 的宽高，停靠在左上    fitCenter  按比例缩放至图片的宽高均小于等于 View 的宽高，停靠在中间    fitEnd  按比例缩放至图片的宽高均小于等于 View 的宽高，停靠在右下    center  不缩放，停靠在 View 中间    centerCrop  按比例缩放至图片的宽高均大于等于 View 的宽高，停靠在中间    centerInside  不缩放，或按比例缩小至图片的宽高均小于等于 View 的宽高，停靠在中间  ",
      "url"      : "https://blog.shcat.top/wiki/android-view-imageview/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "LinearLayout",
      "category" : "",
      "content": "实现方法 元素间分隔线 &lt;LinearLayout  ...  android:showDividers=none|beginning|end|middle  android:divider=@drawable/divider  android:dividerPadding=16dp  &gt; &lt;/LinearLayout&gt; showDividers 控制是否显示分割线 divider 分割线 drawable dividerPadding 分割线 padding，若是横线，则 padding 左右，若是竖线，则 padding 上下 ",
      "url"      : "https://blog.shcat.top/wiki/android-view-linearlayout/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "ListView",
      "category" : "",
      "content": "优化 ListView 使用的方法  利用好 convertView 来重用 View。   使用 ViewHolder，减少 findViewById。   利用好 View Type，不创建过多类型，更利于 View 复用。   让 ItemView 的层次结构简单，善用自定义 View。   尽量使 Adapter 的 hasStableIds() 返回 true，这样在 notifyDataSetChanged() 的时候，如果 id 不变，ListView 将不会重新绘制这个 View，达到优化的目的。   每个 Item 不要太高，不要超屏幕的高度。   getView() 中尽量少做事，不要有耗时的操作，比如滑动时不要加载图片，停止了再加载（Glide 库可以实现这种）。   有些场景可以使用 RecyclerView 来代替，ListView 每次更新数据都要 notifyDataSetChanged()，RecyclerView 的性能和可定制性上都有很大改善。   不要在 getView 里创建 View 的 OnClickListener，position 和数据可以通过 View 的 tag 带上。   setText() 时先比较内容是否变化，比较内容比重绘控件节省资源。 如何防止异步加载图片闪烁错位的问题 将 uri 设置到 ImageView 的 tag 里，图片下载/准备好之后比较 uri 是否还是 ImageView 的 tag 保存的相同，不相同就不加载。 CheckBox 选中状态错位的问题 因为 View 复用引起。将每个 entity 对应的选中状态保存，在 getView 的时候都检查和设置 checkBox 的状态。可以在 entity 中保存状态，也可以额外使用一个 SparseArray 来存储。 PS：其实这都不能算是个问题，设计良好的程序当然会考虑到这个情况，但网上对此的讨论却非常多，sigh。 ListView 与 RecyclerView 比较  RecyclerView 引入 LayoutManager，布局更灵活。   RecyclerView 强制作用 ViewHolder，不用自己 setTag() 了。   RecyclerView 没有 EmptyView、HeaderView 和 FooterView，需要自己实现。   RecyclerView 支持局部刷新，ListView 得自己实现。   RecyclerView 提供了 ItemAnimator。   RecyclerView 提供的是 addOnItemTouchLister，而 ListView 直接提供了 click、long click 和 select 的处理。   RecyclerView 支持嵌套滚动机制。 添加 HeaderView 在 API 17 及以前，addHeaderView 需要在 setAdapter 之前设置，分析见 http://blog.csdn.net/mtt1987/article/details/38535249。 数据更新后自动滚动到底部 android:stackFromBottom=true android:transcriptMode=alwaysScroll or listView.setTranscriptMode(ListView.TRANSCRIPT_MODE_ALWAYS_SCROLL); 参考  优化 listview 有哪些方法？ - 知乎 RecyclerView 和 ListView 使用对比分析 Listview Scroll to the end of the list after updating the list ",
      "url"      : "https://blog.shcat.top/wiki/android-view-listview/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "RecyclerView",
      "category" : "",
      "content": "常见问题解决 设置 OnItemClickListener class MyAdapter extends android.support.v7.widget.RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; { private OnItemClickListener mItemClickListener; interface OnItemClickListener {  void onItemClick(int position);  } MyAdapter(OnItemClickListener itemClickListener) {  mItemClickListener = itemClickListener;  } // ... static class ViewHolder extends RecyclerView.ViewHolder {  ViewHolder(View v, final OnItemClickListener listener) {   super(v);   v.setOnClickListener(new View.OnClickListener() {    @Override    public void onClick(View view) {    listener.onItemClick(getLayoutPosition());    }   });  }  } } RecyclerView.Adapter mAdapter = new MyAdapter(new MyAdapter.OnItemClickListener() {  @Override  public void onItemClick(int position) {  // ...  } }); mRecyclerView.setAdapter(mAdapter); 解决 ScrollView 嵌套 RecyclerView 的显示及滑动问题 一种方法是使用 NestedScrollView，还有其它方法， 参见 https://segmentfault.com/a/1190000011553735 ",
      "url"      : "https://blog.shcat.top/wiki/android-view-recyclerview/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "TabLayout",
      "category" : "",
      "content": "用法 设置字体大小 layout/xxx.xml &lt;android.support.design.widget.TabLayout  ...  app:tabTextAppearance=@style/MineTabLayout  ... /&gt; values/styles.xml &lt;style name=MineTabLayout parent=TextAppearance.Design.Tab&gt;  &lt;item name=android:textSize&gt;@dimen/font_tab&lt;/item&gt; &lt;/style&gt; ",
      "url"      : "https://blog.shcat.top/wiki/android-view-tablayout/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "TextView",
      "category" : "",
      "content": "常见问题及解决方案 限制为单行 android:lines=1 文字过长时省略或跑马灯 android:ellipsize=end 取值可以有 start、middle、end 和 marquee。 添加边框 layout/layout_xxx.xml &lt;TextView  ...  android:background=@drawable/text_border  ... /&gt; drawable/text_border.xml &lt;?xml version=1.0 encoding=utf-8?&gt; &lt;shape xmlns:android=http://schemas.android.com/apk/res/android&gt;  &lt;solid android:color=@android:color/transparent /&gt;  &lt;stroke android:color=#cccccc android:width=1px /&gt; &lt;/shape&gt; 一个大的 TextView 里文字居中 &lt;TextView  ...  android:gravity=center  ... /&gt; drawableRight 和 drawablePadding drawableRight 就是在 View 的右边，它与文字的间距优先取决于 View 的宽度，也就是说，如果 View 很宽，drawableRight 与文字的间距大于 drawablePadding 的话，drawablePadding 看起来就没有效果。 这种情况下可以：  将 View 宽度设为 wrap_content，这样文字与 drawableRight 就基本挨着了，然后再设置 drawablePadding；   设置 View 的 paddingRight 将 drawable 挤过来，但这样很不灵活；   修改 TextView 的绘制实现。 ",
      "url"      : "https://blog.shcat.top/wiki/android-view-textview/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "Toolbar",
      "category" : "",
      "content": "修改 Navigation Icon 的 Padding 值 styles.xml &lt;style name=AppTheme.Base parent=Theme.AppCompat.Light&gt;  &lt;item toolbarNavigationButtonStyle&gt;@style/MyToolbarNavigationButtonStyle&lt;/item&gt; &lt;/style&gt; &lt;style name=MyToolbarNavigationButtonStyle parent=@style/Widget.AppCompat.Toolbar.Button.Navigation&gt;  &lt;item name=android:paddingLeft&gt;14dp&lt;/item&gt;  &lt;item name=android:paddingTop&gt;12dp&lt;/item&gt;  &lt;item name=android:paddingBottom&gt;12dp&lt;/item&gt;  &lt;item name=android:minWidth&gt;0dp&lt;/item&gt;  &lt;item name=android:scaleType&gt;centerInside&lt;/item&gt; &lt;/style&gt; ",
      "url"      : "https://blog.shcat.top/wiki/android-view-toolbar/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "ViewPager",
      "category" : "",
      "content": "获取 ViewPager 中的当前 Fragment Fragment fragment = (Fragment) mAdapter.instantiateItem(mViewPager, mViewPager.getCurrentItem()); 参考：  一行代码获取ViewPager中当前显示的Fragment ",
      "url"      : "https://blog.shcat.top/wiki/android-view-viewpager/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "WebView",
      "category" : "",
      "content": "WebViewClient 与 WebChromeClient WebViewClient 主要涉及与页面加载相关的一些事件回调和处理，我理解应该更多是与 WebView 背后的运行机制的交互。 WebChromeClient 主要是标题、图标、加载进度、JS 弹窗、文件选择和一些视图显隐的控制，我理解主要是与 WebView 界面显示部分的交互。 ",
      "url"      : "https://blog.shcat.top/wiki/android-view-webview/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "View",
      "category" : "",
      "content": "工作流程 主要是 measure、layout、draw 三大流程，即测量、布局和绘制，其中 measure 确定 View 的测量宽/高，layout 确定 View 的最终宽高和四个顶点的位置，而 draw 则将 View 绘制到屏幕上。  View 的最终大小是在 layout 阶段确定的，但是几乎所有情况下 View 的测量大小和最终大小是相等的。   View 的绘制过程分以下几步：    绘制背景 background.draw(canvas)     绘制自己（onDraw）     绘制 children（dispatchDraw）     绘制装饰（onDrawScrollbars）   Baseline View 的文字的底部对齐线相对 View 顶部的距离，像 ImageView 这种默认没有文字的，需要在 xml 里显式设置 android:baseline=20dp，不然在 RelativeLayout 里的其它 View 想要 android:layout_alignBaseline=@id/xxx 时会不生效。 双缓冲机制 在绘制控件时，先将要绘制的内容绘制在一张图片中，再将图片一次性绘制到控件上。 View 与 SurfaceView  View 必须在 UI 线程更新画面，速度较慢，如果更新画面耗时较长，有可能造成 UI 卡顿。   SurfaceView 基于 View 进行拓展，更适合 2D 游戏的开发，类似使用双缓冲机制，可以在新的线程中更新画面所以刷新速度比 View 快，可能需要处理线程同步的问题。   GLSurfaceView 基于 SurfaceView 拓展，用于 OpenGL 3D 游戏开发。 一般来讲，在游戏开发中如棋类这种被动更新画面的，使用 View 就好了，跑酷类等需要主动更新画面的，使用 SurfaceView 更合适。 GPU 过度绘制 在「开发者选项」-「调试 GPU 过度绘制」可以打开显示。 颜色显示：  控件本身的颜色 绘制一次。   蓝色 绘制二次。   绿色 绘制三次。   粉红色 绘制四次。   红色 绘制五次。  可能的原因：  完全看不到的地方也设置了背景色。 最佳实践： 看不到的界面就不绘制。 参考  Android之View和SurfaceView ",
      "url"      : "https://blog.shcat.top/wiki/android-view/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "AsciiDoc Intro",
      "category" : "",
      "content": "Content here ",
      "url"      : "https://blog.shcat.top/wiki/asciidoc-intro/",
      "keywords" : "AsciiDoc"
    } ,
  
    {
      "title"    : "Axure",
      "category" : "",
      "content": "快捷键 C –&gt; Ctrl S –&gt; Shift M –&gt; Alt Cmd –&gt; Command 常用操作    功能  Windows  Mac OS X     当前页面下新建页面  C-Return       预览  F5       生成 HTML 文件  F8       置于顶层  C-S-]       置于底层  C-S-[       上移一层  C-]       下移一层  C-[       开关左侧功能栏  C-M-[       开关右侧功能栏  C-M-]      操作多个元件    功能  Windows  Mac OS X     左对齐  C-M-l       左右居中  C-M-c       右对齐  C-M-r       顶部对齐  C-M-t       上下居中  C-M-m       底部对齐  C-M-b       组合  C-g     ",
      "url"      : "https://blog.shcat.top/wiki/axure/",
      "keywords" : "Axure RP"
    } ,
  
    {
      "title"    : "Badminton",
      "category" : "",
      "content": "视频 李在福系列：  追球（基础系列） 双打 混双 杀球技巧 网前扑球 反手后场高球 步伐 步伐训练 论球 公众号  和蔡赟聊羽毛球 微信号：caiyunliaoyumaoqiu 动作要领笔记 双打反手发网前球  持球手大拇指和食指捏住羽毛，其余三指自然伸直； 主要是手腕发力，大小臂都保持稳定； ",
      "url"      : "https://blog.shcat.top/wiki/badminton/",
      "keywords" : "羽毛球"
    } ,
  
    {
      "title"    : "单例模式",
      "category" : "",
      "content": "解决的问题  限制唯一实例   提供一种易于全局访问实例的方式 与静态类的比较  什么时候使用静态类更好 比如 java.lang.Math 类这种工具类，不维护任何状态，仅提供全局的方法访问，这个时候用静态类更好，因为方法调用都是编译期绑定。 不建议使用静态类维护状态信息，特别是在并发环境下容易出现 race condition。   静态类和单例之间的区别   静态类有更好的性能，因为方法调用都是编译期绑定。  如果需要维护状态，使用单例更合适。  如果对象很大，单例可以懒加载。   单例的优势 更加面向对象。可以通过继承基类和实现接口，享受继承和多态的便利。 如果只是需要一系列静态方法的集合时，使用静态类，其它情况下使用单例。 参考  Difference between Singleton Pattern vs Static Class in Java ",
      "url"      : "https://blog.shcat.top/wiki/basis-dp-singleton/",
      "keywords" : "Basis"
    } ,
  
    {
      "title"    : "模板方法模式",
      "category" : "",
      "content": "定义 在父类中实现一个算法不变的部分，并将可变的行为留给子类来实现。 Android 中的应用 AsyncTask、Activity、Fragment、Service 等的生命周期方法。 ",
      "url"      : "https://blog.shcat.top/wiki/basis-dp-template-method/",
      "keywords" : "Basis"
    } ,
  
    {
      "title"    : "设计模式",
      "category" : "",
      "content": "设计模式可归纳分类如下： 创建型模式  简单工厂模式（Simple Factory）   工厂方法模式（Factory Method）   抽象工厂模式（Abstract Factory）   创建者模式（Builder）   原型模式（Prototype）   单例模式（Singleton） 结构型模式  外观模式（Facade）   适配器模式（Adapter）   代理模式（Proxy）   装饰模式（Decorator）   桥模式（Bridge）   组合模式（Composite）   享元模式（Flyweight） 行为型模式  模板方法模式（Template Method）   观察者模式（Observer）   状态模式（State）   策略模式（Strategy）   职责链模式（Chain of Responsibility）   命令模式（Command）   访问者模式（Visitor）   调停者模式（Mediator）   备忘录模式（Memento）   迭代器模式（Iterator）   解释器模式（Interpreter）  ",
      "url"      : "https://blog.shcat.top/wiki/basis-dp/",
      "keywords" : "Basis"
    } ,
  
    {
      "title"    : "串口通信",
      "category" : "",
      "content": "学习资料  串口通信详解.docx 串口通讯（上）——基础概念 RS232串口通信详解（引脚定义,电气特性,传输格式,接收过程,单片机晶振,RS485,RS422） Android 串口开发  https://github.com/scream3r/java-simple-serial-connector ",
      "url"      : "https://blog.shcat.top/wiki/basis-hardware-serial-port/",
      "keywords" : "Basis"
    } ,
  
    {
      "title"    : "网络",
      "category" : "",
      "content": "术语 TCP（Transmission Control Protocol） 传输控制协议，基于连接的服务。 UDP（User Datagram Protocol） 用户数据报协议，无连接的服务。 IP（Internet Protocol） Internet 协议，信息传递机制。 TCP  TCP 是一个流式设备，是一个虚拟的连接。从 TCP 建立连接开始，到连接正常结束，所有的数据应看成一个整体，它保证的是发送端发送的这个整体和接收端接收的整体是一致的。而直至 TCP 断开前，接收端是不知道发送端发送的是多大的数据，怎么改善的，还有多少数据。所以，在应用中，不应对 TCP 是如何交付数据存在假设。 滑动窗口 三次握手 四次挥手 TCP 与 UDP 的区别  基于连接与无连接   对系统资源的要求（TCP 较多，UDP 少）   TCP 提供较复杂的连接状态、收发状态和超时重传等控制流程  TCP 头部 20 字节比 UDP 的 8 字节多   UDP 程序结构较简单 因为流是连续、有序的，TCP 需要自行处理数据的成帧，而 UDP 每次接收一个数据包，保留报文边界。   流模式与数据报模式   TCP 保证数据正确性，UDP 可能丢包  TCP 保证数据顺序，UDP 不保证   TCP 使用滑动窗口协议进行流量控制   TCP 的逻辑通信通道是全双工的可靠信道，UDP 不可靠   TCP 连接为点到点，而 UDP 运行一对一，一对多，多对一和多对多的交互通信 UDP 适用于需要高速传输和对实时性要求较高的通信或广播，TCP 适用于偏重数据顺序和可靠性的场景。 参考  TCP 与 UDP 的区别 TCP 协议下 socket 有可能丢包吗？ ",
      "url"      : "https://blog.shcat.top/wiki/basis-network/",
      "keywords" : "Basis"
    } ,
  
    {
      "title"    : "面向对象",
      "category" : "",
      "content": "六大原则 即常说的 SOLID+。 单一职责原则 Single Responsibility Principle (SRP) 一个类只做一件事，应该有且仅有一个原因引起类的变更。 开闭原则 Open-Close Principle (OCP) 类和模块应该对拓展开放，对修改关闭。 里氏代换原则 Liskov Substitution Principle (LSP) 所有引用基类的地方必须能透明地使用其子类对象。 接口隔离原则 Interface Segregation Principle (ISP) 一个类对另一个类的依赖应该建立在最小的接口上，不应该依赖和知道它不需要的接口。 依赖倒置原则 Dependency Inversion Principle (DIP) 高层模块不应依赖低层模块，两者都应该依赖抽象，抽象不应依赖细节，细节依赖抽象。 迪米特法则 Law of Demeter (LOD) Only talk to your immediate friends. 也称最小知识原则（Least Knowledge Principle），一个类应该对自己需要耦合或调用的类知道的最少，依赖尽可能少的接口，每个接口又仅包含需要的方法。 ",
      "url"      : "https://blog.shcat.top/wiki/basis-oop/",
      "keywords" : "Basis"
    } ,
  
    {
      "title"    : "I/O 模型",
      "category" : "",
      "content": "概念理解 同步与异步 多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。 阻塞与非阻塞 当请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息。 同步 I/O 与异步 I/O 数据拷贝阶段是由用户线程完成还是内核完成（必须要有操作系统的底层支持）。 阻塞 I/O 与非阻塞 I/O 在数据未就绪的情况下，是返回一个标志位还是一直等待。 I/O 模型 阻塞 I/O 模型 非阻塞 I/O 模型 多路复用 I/O 模型 Java NIO 属于这一种，使用 select() 去查询每个通道是否有到达事件，没有事件则阻塞。 信号驱动 I/O 模型 异步 I/O 模型 参考  Java NIO：浅析I/O模型 ",
      "url"      : "https://blog.shcat.top/wiki/basis-os-io/",
      "keywords" : "Basis"
    } ,
  
    {
      "title"    : "进程",
      "category" : "",
      "content": "用户空间与内核空间  现代操作系统上，物理内存不再对程序可见，也就是说，程序指令以及其访问数据都处在虚拟地址空间，机器通过一个叫做 MMU 的机构将其映射为真实的物理内存页面。 而进程的空间实际上被分为了两个部分，一部分供进程使用，称为用户空间，一部分供内核使用，称为内核空间。用户空间是进程间隔离的，内核空间是共享的。  具体到 4GB 内存的 32 位 Windows 系统上，低 2GB 是用户空间，高 2GB 是内核空间，也就是说每个进程看到的高 2GB 空间的内容是一样的。而 Linux 系统将高 1GB 空间映射为内核空间，对应低 1GB 的物理内存。（有 3GB/1GB，2GB/2GB，4GB/4GB 等模式，以上参数实际上可调。） 程序运行在用户态时为了要访问内核的资源，必须经过内核提供的接口，通过系统调用（Linux 下就是 int 0x80）中断，中断号由 eax 传入，参数由 ebx ecx edx 压栈等方式传入，发生了中断则现场保护，控制权交给内核，由内核根据中断号调用相应函数，结束后清栈，pc 指向原保存的返回地址，回到用户态。 参考  Kernel Space Definition 用户空间/内核空间 Windows/Linux内核地址空间管理的异同 ",
      "url"      : "https://blog.shcat.top/wiki/basis-os-process/",
      "keywords" : "Basis"
    } ,
  
    {
      "title"    : "线程安全与可重入",
      "category" : "",
      "content": "可重入函数未必是线程安全的，线程安全函数也未必是可重入的。 线程安全 线程安全指某个函数、函数库在多线程环境中被调用时，能够正确处理多个线程之间的共享变量，使程序功能正确完成。 可重入 若一个程序或子程序可以“在任意时刻被中断然后操作系统调试执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时的预期的结果。与多线程并发执行的线程安全不同，可重入强调的是对单个线程执行时重新进入同一个子程序仍然是安全的。 若一个函数是可重入的，则该函数应当满足下述条件：  不能含有静态（全局）非常量数据。 不能返回静态（全局）非常量数据的地址。 只能处理由调用者提供的数据。 不能依赖于单实例模式资源的锁。 调用的函数也必须是可重入的。 参考  线程安全 可重入 ",
      "url"      : "https://blog.shcat.top/wiki/basis-os-thread-safe-and-reentrant/",
      "keywords" : "Basis"
    } ,
  
    {
      "title"    : "线程",
      "category" : "",
      "content": "终止线程 四种方法：  线程函数返回（强烈推荐）。 线程通过调用 ExitThread “杀死”自己（避免使用）。 同一进程或另一进程中的线程调用 TerminateThread 函数（避免使用）。 包含线程的进程终止运行（避免使用）。 线程终止运行时的清理工作：  线程函数中创建的所有栈内对象都通过其析构函数被正确销毁。 操作系统正确释放线程栈使用的内存。 操作系统把线程的退出代码（在线程的内核对象中维护）设为线程函数的返回值。 系统递减线程的内核对象的使用计数。 线程终止运行时会发生的事情：  线程拥有的所有用户对象句柄会被释放（window 和 hook）。 线程的退出代码从 STILL_ACTIVE 变成传给 ExitThread 或 TerminateThread 的代码。 线程内核对象的状态变为触发状态。 如果线程是进程中的最后一个活动线程，系统认为进程也终止了。 线程内核对象的使用计数减一。 其关联的线程对象不会自动释放，除非对这个对象的所有未结束引用都被关闭。 参考  《Windows 核心编程》第五版 ",
      "url"      : "https://blog.shcat.top/wiki/basis-os-thread/",
      "keywords" : "Basis"
    } ,
  
    {
      "title"    : "中文文案排版指北（简体中文版）",
      "category" : "",
      "content": "GitHub repository: mzlogin/chinese-copywriting-guidelines 统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。 Other languages:  Chinese Traditional English  目录  空格   中英文之间需要增加空格  中文与数字之间需要增加空格  数字与单位之间无需增加空格  全角标点与其他字符之间不加空格  -ms-text-autospace to the rescue?   标点符号   不重复使用标点符号   全角和半角   使用全角中文标点  数字使用半角字符  遇到完整的英文整句、特殊名词，其內容使用半角标点   名词   专有名词使用正确的大小写  不要使用不地道的缩写   争议   链接之间增加空格  简体中文使用直角引号   工具 谁在这样做？ 参考文献 空格 「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。 与大家共勉之。」——vinta/paranoid-auto-spacing 中英文之间需要增加空格 正确：  在 LeanCloud 上，数据存储是围绕 AVObject 进行的。 错误：  在LeanCloud上，数据存储是围绕AVObject进行的。 在 LeanCloud上，数据存储是围绕AVObject 进行的。 完整的正确用法：  在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。 例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。 中文与数字之间需要增加空格 正确：  今天出去买菜花了 5000 元。 错误：  今天出去买菜花了 5000元。 今天出去买菜花了5000元。 数字与单位之间无需增加空格 正确：  我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。 错误：  我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。 另外，度／百分比与数字之间不需要增加空格： 正确：  今天是 233° 的高温。 新 MacBook Pro 有 15% 的 CPU 性能提升。 错误：  今天是 233 ° 的高温。 新 MacBook Pro 有 15 % 的 CPU 性能提升。 全角标点与其他字符之间不加空格 正确：  刚刚买了一部 iPhone，好开心！ 错误：  刚刚买了一部 iPhone ，好开心！ -ms-text-autospace to the rescue? Microsoft 有个 -ms-text-autospace 的 CSS 属性可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 OS X、iOS 的用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。 标点符号 不重复使用标点符号 正确：  德国队竟然战胜了巴西队！ 她竟然对你说「喵」？！ 错误：  德国队竟然战胜了巴西队！！ 德国队竟然战胜了巴西队！！！！！！！！ 她竟然对你说「喵」？？！！ 她竟然对你说「喵」？！？！？？！！ 全角和半角 不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全角和半角』。 使用全角中文标点 正确：  嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！ 核磁共振成像（NMRI）是什么原理都不知道？JFGI！ 错误：  嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎! 嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎! 核磁共振成像 (NMRI) 是什么原理都不知道? JFGI! 核磁共振成像(NMRI)是什么原理都不知道?JFGI! 数字使用半角字符 正确：  这件蛋糕只卖 1000 元。 错误：  这件蛋糕只卖 １０００ 元。 例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。 遇到完整的英文整句、特殊名词，其內容使用半角标点 正确：  乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」 推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。 错误：  乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」 推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。 名词 专有名词使用正确的大小写 大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论內容，在这里只对部分易错用法进行简述。 正确：  使用 GitHub 登录 我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。 错误：  使用 github 登录 使用 GITHUB 登录 使用 Github 登录 使用 gitHub 登录 使用 gｲんĤЦ8 登录 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。 我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。 我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。 我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。 我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。 注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标准的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。 不要使用不地道的缩写 正确：  我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。 错误：  我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。 争议 以下用法略带有个人色彩，既：无论是否遵循下述规则，从语法的角度来讲都是正确的。 链接之间增加空格 用法：  请 提交一个 issue 并分配给相关同事。 访问我们网站的最新动态，请 点击这里 进行订阅！ 对比用法：  请提交一个 issue 并分配给相关同事。 访问我们网站的最新动态，请点击这里进行订阅！ 简体中文使用直角引号 用法：  「老师，『有条不紊』的『紊』是什么意思？」 对比用法：  “老师，‘有条不紊’的‘紊’是什么意思？” 工具    仓库  语言     vinta/paranoid-auto-spacing  JavaScript    huei90/pangu.node  Node.js    huacnlee/auto-correct  Ruby    sparanoid/space-lover  PHP (WordPress)    nauxliu/auto-correct  PHP    hotoo/pangu.vim  Vim    sparanoid/grunt-auto-spacing  Node.js (Grunt)    hjiang/scripts/add-space-between-latin-and-cjk  Python   谁在这样做？    网站  文案  UGC     Apple 中国  Yes  N/A    Apple 香港  Yes  N/A    Apple 台湾  Yes  N/A    Microsoft 中国  Yes  N/A    Microsoft 香港  Yes  N/A    Microsoft 台湾  Yes  N/A    LeanCloud  Yes  N/A    知乎  Yes  部分用户达成    V2EX  Yes  Yes    SegmentFault  Yes  部分用户达成    Apple4us  Yes  N/A    豌豆荚  Yes  N/A    Ruby China  Yes  标题达成    PHPHub  Yes  标题达成   参考文献  Guidelines for Using Capital Letters Letter case - Wikipedia Punctuation - Oxford Dictionaries Punctuation - The Purdue OWL How to Use English Punctuation Corrently - wikiHow 格式 - openSUSE 全角和半角 - 维基百科 引号 - 维基百科 疑问惊叹号 - 维基百科 ",
      "url"      : "https://blog.shcat.top/wiki/chinese-copywriting-guidelines/",
      "keywords" : "中文文案排版指北"
    } ,
  
    {
      "title"    : "Eclipse",
      "category" : "",
      "content": "快捷键 C –&gt; Ctrl S –&gt; Shift A –&gt; Alt    功能  快捷键     显示所有快捷键  C-S-l    开/关注释  C-/    显示 outline  C-o    当前打开的文件列表  C-e    快速查找打开文件  C-S-r    查找  C-h    查找后跳到下一处  C-.    Undo  C-z    Redo  C-y    跳到指定行  C-l    自动补全  A-/    自动解决导入包问题  C-S-o    返回  A-Left    反返回  A-Right    步进  F5    单步  F6    执行到返回  F7    继续执行  F8    删除当前行  C-d    删除前一个词  C-Backspace    删除后一个词  C-Delete    缩进  Tab    减少缩进  S-Tab    在下面新起一行  S-Enter    在上面新起一行  C-S-Enter   Q&amp;A  如何解决 Mac OS X 下安装的是 Java 1.8，运行 Eclipse 时提示「您需要安装旧 Java SE 6 运行环境才能打开「Eclipse.app」。」的问题？  更改 /Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Info.plist 文件里的 JVMCapabilities 段如下（默认只有 CommandLine）：  &lt;key&gt;JVMCapabilities&lt;/key&gt;   &lt;array&gt;    &lt;string&gt;JNI&lt;/string&gt;    &lt;string&gt;BundledApp&lt;/string&gt;    &lt;string&gt;WebStart&lt;/string&gt;    &lt;string&gt;Applets&lt;/string&gt;    &lt;string&gt;CommandLine&lt;/string&gt;   &lt;/array&gt;   然后重启电脑。 没有找到为何这样改的解释，按名称猜想应该是说在这几种环境下启动 Java 具有跨版本的兼容性吧。  ",
      "url"      : "https://blog.shcat.top/wiki/eclipse/",
      "keywords" : "Eclipse"
    } ,
  
    {
      "title"    : "Emacs",
      "category" : "",
      "content": "约定：C- 前缀表示 Ctrl，M- 前缀表示 Alt，S- 前缀表示 Shift，上档字符比如 @ 的实际按键应为 Shift+2。 目录  移动 编辑 缓冲区 窗口 文件 代码 命令 重复 外部命令 模式 显示 搜索 帮助 右键菜单 插件   evil-nerd-commenter  function-args  hexl-mode  ido  jedi  projectile  python  package   其它需求   统计字数   移动 上 C-p 下 C-n 左 C-b 右 C-f 前一个词首 M-b 后一个词尾 M-f 跳到某一行 M-gg 行首 C-a 行尾 C-e 句首/前一个句首 M-a 名尾/前一个句尾 M-e 向前一个段落 M-{ 向后一个段落 M-} 下翻页 C-v 上翻页 M-v 跳到文首 M-&lt; 跳到文尾 M-&gt; 当前光标行移动到屏显上/中/下部 C-l 编辑 选取块 C-@ 复制 M-w 剪切 C-w 粘贴 C-y 全选 C-x h 切换只读/编辑模式 C-x C-q 交换当前字符与前一字符 C-t 交换当前单词与后一单词 M-t 交换当前行与上一行 C-x C-t 撤消 C-/ 或 C-x u 撤消撤消 C-g C-/ 当前单全大写 M-u 当前单词全小写 M-l 缓冲区 查看所有打开的缓冲区 C-x C-b 切换缓冲区 C-x b 关闭缓冲区 C-x k 关闭 emacsclientw.exe 打开的缓冲区 C-x # 窗口 关闭其它窗口 C-x 1 关闭当前窗口 C-x 0 在下面分割出一个窗口 C-x 2 在右边分割出一个窗口 C-x 3 依次切换到其它窗口 C-x o 文件 打开文件 C-x C-f 保存文件 C-x C-s 保存所有打开的文件 C-x s 在当前位置插入某文件内容 C-x i 代码 注释选中块 C-x r t 反注释选中块 C-x r k 注释/反注释 M-; 格式化光标之前的代码 C-M-   与上一行合并 M-^ 带注释前缀换行 M-j 解释运行当前 elisp 语句/函数 C-M-x 命令 输入命令 M-x 运行 SHELL shell 运行 ESHELL eshell 列出 elpa 上可用包 list-packages 安装插件 package-install 格式化输出 JSON json-pretty-print-buffer elisp 交互解释器 ielm 解释运行当前 Buffer eval-buffer 中止一个操作 C-g 对选中区域执行命令 M-| 重复 重复操作 50 次 M-50 命令 外部命令 输入外部命令 M-! 模式 打开/关闭某个模式 M-x 模式名 显示 放大字体 C-x C-= 缩小字体 C-x C– 重置字体 C-x C-0 自定义颜色 M-x customize-face default 搜索 渐进的搜索 C-s 往回搜索 C-r 按了回车之后继续搜索 C-s C-s 按了回车之后往回搜索 C-r C-r 帮助 查看变量的文档 C-h v 查看函数的文档 C-h f 查看某快捷键说明 C-h k 打开 Tutorial C-h t 打开帮助文档 C-h i 右键菜单 将如下代码命令为 .reg 文件，运行后可为鼠标右键添加菜单项「Edit with Emacs」（运行之前将 exe 路径先替换为自己的）。 前提是在配置文件里添加了 (server-start)。 Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT  *  shell  Edit with Emacs] [HKEY_CLASSES_ROOT  *  shell  Edit with Emacs  command] @=  D:    emacs    bin    emacsclientw.exe   -a   D:    emacs    bin    runemacs.exe     %1   插件 evil-nerd-commenter 注释/反注释 M-; 注释多行 M-9 M-; function-args 提示函数参数 M-i 显示本文件大纲选择某项后跳转 C-M-j 跳转到函数定义（显示函数参数的时候有效） M-j hexl-mode 进入十六进制模式 M-x hexl-mode 退出十六进制模式 M-x hexl-mode-exit 输入十六进制数 M-x hexl-insert-hex-char ido 切换到上一个选项 C-r 切换到下一个选项 C-s jedi 显示光标处 Python 模块或函数的文档 C-c ? projectile 显示/刷新当前项目文件列表 C-c p f python 打开 Python 交互式Shell C-c C-p package 升级已安装的包 U 标记要安装的包 i 标记要删除的包 d 取消标记 u 执行操作 x 上一行 p 下一行 n 刷新包列表 r 重置缓冲区 g 退出窗口 q 其它需求 统计字数 （前提是 shell 下能运行 wc 程序）  选中要统计区域 M-| wc -c ",
      "url"      : "https://blog.shcat.top/wiki/emacs/",
      "keywords" : "Emacs, 快捷键"
    } ,
  
    {
      "title"    : "Excel",
      "category" : "",
      "content": "小技巧 查找重复项  选中查找区域； 开始-样式-条件格式-突出显示单元格规则-重复值，在弹出的对话框中设置重复值格式； 此时如果重复值，已经被标记为指定的格式。 在汇总行上方插入行后自动求和 比如有以下表格： 当前 B5 单元格的公式为 =SUM(B2:B4)，但是在汇总行上面插入一行新的记录后，汇总数据不会自动更新。 这时候可以使用以下两个公式，实现在汇总行上面插入新的行后，汇总数据自动求和： =SUM(INDIRECT(B2:B&amp;ROW()-1)) =SUM(OFFSET(B1,,,ROW()-1,)) 参考：http://www.icanzc.com/excel/3689.html ",
      "url"      : "https://blog.shcat.top/wiki/excel/",
      "keywords" : "Excel, Office"
    } ,
  
    {
      "title"    : "Git",
      "category" : "Git",
      "content": "常用命令    功能  命令     添加文件/更改到暂存区  git add filename    添加所有文件/更改到暂存区  git add .    提交  git commit -m msg    从远程仓库拉取最新代码  git pull origin master    推送到远程仓库  git push origin master    查看配置信息  git config –list    查看文件列表  git ls-files    比较工作区和暂存区  git diff    比较暂存区和版本库  git diff –cached    比较工作区和版本库  git diff HEAD    从暂存区移除文件  git reset HEAD filename    查看本地远程仓库配置  git remote -v    回滚  git reset –hard 提交SHA    强制推送到远程仓库  git push -f origin master    修改上次 commit  git commit –amend    推送 tags 到远程仓库  git push –tags    推送单个 tag 到远程仓库  git push origin [tagname]    删除远程分支  git push origin –delete [branchName]    远程空分支（等同于删除）  git push origin :[branchName]    查看所有分支历史  gitk –all    按日期排序显示历史  gitk –date-order   Q&amp;A 如何解决gitk中文乱码，git ls-files 中文文件名乱码问题？ 在~/.gitconfig中添加如下内容 [core] quotepath = false [gui] encoding = utf-8 [i18n] commitencoding = utf-8 [svn] pathnameencoding = utf-8 参考 http://zengrong.net/post/1249.htm 如何处理本地有更改需要从服务器合入新代码的情况？ git stash git pull git stash pop stash 查看 stash 列表： git stash list 查看某一次 stash 的改动文件列表（不传最后一个参数默认显示最近一次）： git stash show stash@{0} 以 patch 方式显示改动内容 git stash show -p stash@{0} 应用某次 stash 改动内容： git stash apply stash@{0} 如何合并 fork 的仓库的上游更新？ git remote add upstream https://upstream-repo-url git fetch upstream git merge upstream/master 如何通过 TortoiseSVN 带的 TortoiseMerge.exe 处理 git 产生的 conflict？ 将 TortoiseMerge.exe 所在路径添加到 path 环境变量。 运行命令 git config --global merge.tool tortoisemerge 将 TortoiseMerge.exe 设置为默认的 merge tool。  在产生 conflict 的目录运行 git mergetool，TortoiseMerge.exe 会跳出来供你 resolve conflict。   也可以运行 git mergetool -t vimdiff 使用 -t 参数临时指定一个想要使用的 merge tool。   不想跟踪的文件已经被提交了，如何不再跟踪而保留本地文件？ git rm --cached /path/to/file，然后正常 add 和 commit 即可。 如何不建立一个没有 parent 的 branch？ git checkout --orphan newbranch 此时 git branch 是不会显示该 branch 的，直到你做完更改首次 commit。比如你可能会想建立一个空的 gh-pages branch，那么： git checkout --orphan gh-pages git rm -rf . // add your gh-pages branch files git add . git commit -m init commit submodule 的常用命令 添加 submodule git submodule add git@github.com:philsquared/Catch.git Catch 这会在仓库根目录下生成如下 .gitmodules 文件并 clone 该 submodule 到本地。 [submodule Catch] path = Catch url = git@github.com:philsquared/Catch.git 更新 submodule git submodule update 当 submodule 的 remote 有更新的时候，需要 git submodule update --remote 当在本地拉取了 submodule 的远程更新，但是想反悔时： git submodule update --init 删除 submodule 在 .gitmodules 中删除对应 submodule 的信息，然后使用如下命令删除子模块所有文件： git rm --cached Catch clone 仓库时拉取 submodule git submodule update --init --recursive 删除远程 tag git push origin --delete tag [tagname] 基于某次 commit 创建 tag git tag &lt;tag name&gt; &lt;commit id&gt; git tag v1.0.0 ef0120 清除未跟踪文件 git clean 可选项：    选项  含义     -q, –quiet  不显示删除文件名称    -n, –dry-run  试运行    -f, –force  强制删除    -i, –interactive  交互式删除    -d  删除文件夹    -e, –exclude  忽略符合 的文件    -x  清除包括 .gitignore 里忽略的文件    -X  只清除 .gitignore 里忽略的文件   忽略文件属性更改 因为临时需求对某个文件 chmod 了一下，结果这个就被记为了更改，有时候这是想要的，有时候这会造成困扰。 git config --global core.filemode false 参考：How do I make Git ignore file mode (chmod) changes? 忽略除某后缀名以外的所有文件 忽略除了 .c 后缀名以外的所有文件。 * !*.c !*/ gitignore 里，*、?、[] 可用作通配符。 patch 将未添加到暂存区的更改生成 patch 文件： git diff &gt; demo.patch 将已添加到暂存区的更改生成 patch 文件： git diff --cached &gt; demo.patch 合并上面两条命令生成的 patch 文件包含的更改： git apply demo.patch 将从 HEAD 之前的 3 次 commit 生成 3 个 patch 文件： （HEAD 可以换成 sha1 码） git format-patch -3 HEAD 生成 af8e2 与 eaf8e 之间的 commits 的 patch 文件： （注意 af8e2 比 eaf8e 早） git format-patch af8e2..eaf8e 合并 format-patch 命令生成的 patch 文件： git am 0001-Update.patch 与 git apply 不同，这会直接 add 和 commit。 只下载最新代码 git clone --depth 1 git://xxxxxx 这样 clone 出来的仓库会是一个 shallow 的状态，要让它变成一个完整的版本： git fetch --unshallow 或 git pull --unshallow 基于某次 commit 创建分支 git checkout -b test 5234ab 表示以 commit hash 为 5234ab 的代码为基础创建分支 test。 恢复单个文件到指定版本 git reset 5234ab MainActivity.java 恢复 MainActivity.java 文件到 commit hash 为 5234ab 时的状态。 设置全局 hooks git config --global core.hooksPath C:/Users/mazhuang/git-hooks 然后把对应的 hooks 文件放在最后一个参数指定的目录即可。 比如想要设置在 commit 之前如果检测到没有从服务器同步则不允许 commit，那在以上目录下建立文件 pre-commit，内容如下： #!/bin/sh CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD) git fetch origin $CURRENT_BRANCH HEAD=$(git rev-parse HEAD) FETCH_HEAD=$(git rev-parse FETCH_HEAD) if [ $FETCH_HEAD = $HEAD ]; then  echo Pre-commit check passed  exit 0 fi echo Error: you need to update from remote first exit 1 查看某次 commit 的修改内容 git show &lt;commit-hash-id&gt; 查看某个文件的修改历史 git log -p &lt;filename&gt; 查看最近两次的修改内容 git log -p -2 应用已存在的某次更改 / merge 某一个 commit git cherry-pick &lt;commit-hash-id&gt; cherry-pick 有更多详细的用法，可以参见帮助文档。 命令行自动补全 在 shell 里加载 git-completion 系列脚本，详见 https://github.com/git/git/tree/master/contrib/completion 文件每一行变更明细 git blame &lt;filename&gt; 找回曾经的历史 git reflog 列出 HEAD 曾指向过的一系列 commit，它们只存在于本机，不是版本仓库的一部分。 还有： git fsck 记住 http(s) 方式的用户名密码 在有些情况下无法使用 git 协议，比如公司的 git 服务器设置了 IP 白名单，只能在公司内网使用 ssh，那么在外面就只能使用 http(s) 上传下载源码了，但每次都手动输入用户名/密码特别惨，于是乎就记住吧。 设置记住密码（默认 15 分钟）： git config --global credential.helper cache 自定义记住的时间（如下面是一小时）： git config credential.helper 'cache --timeout=3600' 长期存储密码： git config --global credential.helper store git commit 使用 vim 编辑 commit message 中文乱码 这个问题在 Windows 下出现了，没找到能完美解决的办法，一种方法是在 vim 打开后输入： :set termencoding=GBK 这就有点太麻烦了，折衷的方法是改为使用 gVim 或其它你喜欢的编辑器来编辑 commit message： git config --global core.editor gvim 参考： How do I make Git use the editor of my choice for commits? 转：git windows中文 乱码问题解决汇总 另外在升级 Vim 到 8.1 之后，由于 PATH 环境变量里加的还是 vim80 文件夹，导致 git commit 时提示： error: cannot spawn gvim: No such file or directory error: unable to start editor 'gvim' Please supply the message using either -m or -F option. 使用 which gvim 查看： $ which gvim /usr/bin/which: no gvim in xxxxxxx 将 PATH 里添加的 vim80 路径改为 vim81 后解决。 git log 中文乱码 只在 Windows 下遇到。 git config --global i18n.logoutputencoding gbk 编辑 git 安装目录下 etc/profile 文件，在最后添加如下内容： export LESSCHARSET=utf-8 参考：Git for windows 中文乱码解决方案 git diff 中文乱码 只在 Windows 下遇到，目前尚未找到有效办法。 统计代码行数 CMD 下直接执行可能失败，可以在右键，Git Bash here 里执行。 统计某人的代码提交量 git log --author=$(git config --get user.name) --pretty=tformat: --numstat | gawk '{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf added lines: %s removed lines : %s total lines: %s  ,add,subs,loc }' 仓库提交者排名前 5 如果看全部，去掉 head 管道即可。 git log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 5 仓库提交者（邮箱）排名前 5 这个统计可能不太准，可能有同名。 git log --pretty=format:%ae | gawk -- '{ ++c[$0]; } END { for(cc in c) printf %5d %s  ,c[cc],cc; }' | sort -u -n -r | head -n 5 贡献者排名 git log --pretty='%aN' | sort -u | wc -l 提交数统计 git log --oneline | wc -l 参考：Git代码行统计命令集 修改文件名时的大小写问题 修改文件名大小写时，默认会被忽略（在 Windows 下是这样），让 git 对大小写敏感的方法： git config --global core.ignorecase false 或者使用 git mv oldname newname 也是可以的。 修复 gitk 在 macOS 下显示模糊的问题 gitk 很方便，但是在 Mac 系统下默认显示很模糊，影响体验。 根据网上搜索的结果，解决方法有两种，我采用第一种解决，第二种未尝试。 方法一：  重新启动机器，按 command + R 等 Logo 和进度条出现，会进入 Recovery 模式，选择顶部的实用工具——终端，运行以下命令：  csrutil disable   重新启动机器。   编辑 Wish 程序的 plist，启动高分辨率屏支持。  sudo gvim /System/Library/Frameworks/Tk.framework/Versions/Current/Resources/Wish.app/Contents/Info.plist   在最后的 &lt;/dict&gt; 前面加上以下代码  &lt;key&gt;NSHighResolutionCapable&lt;/key&gt; &lt;true/&gt;   更新 Wish.app。  sudo touch Wish.app   再次用 1 步骤的方法进入 Recovery 模式，执行 csrutil enable 启动对系统文件保护，再重启即可。 参考：Mac 中解决 gitk 模糊问题 方法二： brew cask install retinizer open /System/Library/Frameworks/Tk.framework/Versions/Current/Resources/ 打开 retinizer，将 Wish.app 拖到 retinizer 的界面。 参考：起底Git-Git基础 clone 时指定 master 以外的分支 git clone -b &lt;branch name&gt; --single-branch &lt;repo address&gt; 获取当前分支名称 git symbolic-ref --short -q HEAD 解决 no man viewer handled the request 运行命令 git stash --help 报错： warning: failed to exec 'man': Invalid argument fatal: no man viewer handled the request 原因是 Windows 下没有 man 命令。 可以修改 git 配置让命令的帮助文档通过浏览器打开。 git config --global help.format web 比较两个分支的差异 显示出所有差异详情： git diff &lt;branch_name_1&gt; &lt;branch_name_2&gt; 显示有差异的文件列表： git diff &lt;branch_name_1&gt; &lt;branch_name_2&gt; --stat 显示指定文件的差异详情： git diff &lt;branch_name_1&gt; &lt;branch_name_2&gt; &lt;filename&gt; 查看 A 分支有，B 分支没有的提交： git log &lt;branch_name_A&gt; ^&lt;branch_name_B&gt; git 操作时报警告 警告信息： @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @  WARNING: POSSIBLE DNS SPOOFING DETECTED!  @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ The ECDSA host key for gitlab.xxxx.com has changed, and the key for the corresponding IP address 121.40.151.8 is unknown. This could either mean that DNS SPOOFING is happening or the IP address for the host and its host key have changed at the same time. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!  @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the ECDSA key sent by the remote host is SHA256:bud2tDwxl9687vMOUUBGXlwZhjxDTu7eVF43ojAu1Pw. Please contact your system administrator. Add correct host key in /c/Users/mzlogin/.ssh/known_hosts to get rid of this message. Offending ECDSA key in /c/Users/mzlogin/.ssh/known_hosts:1 ECDSA host key for gitlab.xxxx.com has changed and you have requested strict checking. Host key verification failed. fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 解决方案： rm ~/.ssh/known_hosts 然后重新操作即可。 删除不存在对应远程分支的本地分支 （本小节有效性存疑，有时候并不好使。） $ git remote show origin develop      tracked master     tracked feature/new-ui    tracked refs/remotes/origin/feature/test stale (use 'git remote prune' to remove) ... 其中 feature/test 就是不存在远程分支的本地分支。 $ git remote prune origin 清除完成。 ",
      "url"      : "https://blog.shcat.top/wiki/git/",
      "keywords" : "Git, 版本控制"
    } ,
  
    {
      "title"    : "GitHub",
      "category" : "",
      "content": "打开/下载文件加速  项目内的文件 比如要下载 https://github.com/junegunn/vim-plug/plug.vim，那可以将 github.com 替换成 cdn.jsdelivr.net/gh，最终地址 https://cdn.jsdelivr.net/gh/junegunn/vim-plug/plug.vim 参考 https://mazhuang.org/2020/05/01/cdn-for-github-pages/   Releases 里的文件 比如要下载 https://github.com/PowerShell/PowerShell/releases/download/v7.1.0-preview.6/PowerShell-7.1.0-preview.6-win-x64.zip，可以将它填到 https://d.serctl.com/ 下载。 参考 https://toolwa.com/github/  ",
      "url"      : "https://blog.shcat.top/wiki/github/",
      "keywords" : "GitHub"
    } ,
  
    {
      "title"    : "善用佳软",
      "category" : "",
      "content": "好的软件总是给人一种相见恨晚的感觉。 软件列表    功能  Windows  Mac OS X     文本编辑  gVim  MacVim    离线 API 文档  Zeal  Dash / devdocs.io    UML  Visio / draw.io  draw.io    流程图  Visio / draw.io  draw.io / ProcessOn.com    文件查找  Everything  Alfred    文件内容查找  FileLocator  Alfred    Android 开发  Android Studio  Android Studio    Android 虚拟机  Genymotion  Genymotion    Android 当无线鼠标、键盘、远程桌面等  WiFi Mouse  WiFi Mouse    源码阅读  Source Insight  IDE/Vim    笔记  OneNote  OneNote    终端  Windows Terminal / Cmder  zsh    视频播放器  QQ 影音  mpv    下载  迅雷精简版  迅雷    录制屏幕生成 GIF  LICEcap  LICEcap    打开 CHM 文档     ichm    阅读 EPUB 电子书  Neat Reader  iBook    手机投屏     幕享 / AirServer / Macast   亮点 Cmder  alias 在 Cmder 下可以很方便地像在类 Unix 系统下使用 alias 功能，比如： alias blog=cd /d d:  github  mzlogin.github.io   然后就能愉快地使用 blog 命令在任意目录进入 blog 仓库的目录了。 Genymotion 配置好后，那启动速度，嗖嗖地，秒 Android SDK 自带的八条街。 mpv 不像 MPlayerX 和 Perian 那样无故卡死转码半天就是最大的亮点了。 ",
      "url"      : "https://blog.shcat.top/wiki/good-soft/",
      "keywords" : "软件, 推荐"
    } ,
  
    {
      "title"    : "IDA Pro",
      "category" : "",
      "content": "快捷键 C –&gt; Ctrl S –&gt; Shift M –&gt; Alt Cmd –&gt; Command    功能  快捷键     搜索文本  M-t    返回上一个位置  Esc    前进到下一位置  C-Enter    显示伪 C 代码  F5    跳转到地址  g  ",
      "url"      : "https://blog.shcat.top/wiki/ida-pro/",
      "keywords" : "debug, IDA Pro"
    } ,
  
    {
      "title"    : "IntelliJ IDEA",
      "category" : "",
      "content": "快捷键基本与 Android Studio 一致，这里重点记录解决遇到过的问题。 Q&amp;A 如何让代码自动换行显示？ Preferences -&gt; Editor -&gt; General，勾选 Soft-wrap these files，后面的文件名匹配改为 *，表示所有文件都启用自动换行。 如何加大控制台日志缓冲区大小？ 有时候日志量太大，需要的信息被冲出控制台缓冲区，这种时候可以加大缓冲区大小，让它多缓冲一些行数。 Preferences -&gt; Editor -&gt; General -&gt; Console，勾选 Override console cycle buffer size，然后修改后面的数字大小，默认是 1024（单位 KB），比如我修改为了 102400。 解决导入 Eclipse Maven 工程后无法读取 .xml 文件的问题 IDEA 与 Eclipse 配置文件目录的方式不同，可以将文件夹标记为 Sources、Resources 和 tests 等，而 src/main/java 默认被标记为 Sources，src/main/resources 才默认被标记为 Resources，编译时自动复制。 这样放在 src/main/java 目录下的文件与子文件夹均为 Sources，只将编译生成的 .class 文件复制到编译目录，在 Eclipse Maven 工程里放在 src/main/java 文件夹里的 xml、props 和 properties 文件就不会被拷贝到编译文件夹，导致执行时找不到这些文件，报类似下面这样的错误： org.springframework.beans.factory.BeanDefinitionStoreException: IOException parsing XML document from class path resource [spring-demo.xml]; nested exception is java.io.FileNotFoundException: class path resource [spring-demo.xml] cannot be opened because it does not exist  tat org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:343)  tat org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:303)  tat org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:180)  tat org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:216)  tat org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:187)  tat org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:251)  tat org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:127)  tat org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:93)  tat org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:129)  tat org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:540)  tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:454)  tat org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139)  tat org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:83)  tat org.mazhuang.demo.protocol.db.DemoContext.init(DemoContext.java:22)  tat org.mazhuang.demo.protocol.DemoServer.start(DemoServer.java:40)  tat org.mazhuang.demo.DemoSrv.main(DemoSrv.java:17) Caused by: java.io.FileNotFoundException: class path resource [spring-demo.xml] cannot be opened because it does not exist  tat org.springframework.core.io.ClassPathResource.getInputStream(ClassPathResource.java:158)  tat org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:329)  t... 15 more 解决方案： 可以通过在 pom.xml 文件里添加 resources 配置来指定将哪些文件作为 resources 包含： &lt;build&gt;  &lt;resources&gt;  &lt;resource&gt;   &lt;directory&gt;${basedir}/src/main/java&lt;/directory&gt;   &lt;includes&gt;    &lt;include&gt;**/*.props&lt;/include&gt;    &lt;include&gt;**/*.xml&lt;/include&gt;   &lt;/includes&gt;  &lt;/resource&gt;  &lt;/resources&gt; &lt;/build&gt; 如何导出 jar 包 File -&gt; Project Structure -&gt; Artifacts -&gt; Click green plus sign -&gt; Jav -&gt; From modules with dependencies Build -&gt; Build Artifacts 去掉 UTF-8 文件的 BOM UTF-8 文件带 BOM 里会编译报错： Error:(1, 1) error: illegalcharacter: '  ufeff' 解决方法： 右键项目名称 -&gt; Remove BOM FreeMarker 模板实时生效  在配置文件里关闭 FreeMarker 缓存，设置模板更新延迟时间为 0：  spring: freemarker:  cache: false  settings:   template_update_delay: 0   修改 IDEA 设置，开启 Build project automatically    双击 shift，输入 registry，然后回车选中图中项：    找到并勾选 compiler.automake.allow.when.app.running：    重新启动项目。 修改模板后可能会有几秒延时，刷新两遍就好了。 编辑器面包屑配置  面包屑的显示/隐藏，两种方法：   菜单 View - Active Editor - Show Breadcrumbs  右键行号区域 - Breadcrumbs - Top / Bottom / Don’t Show   面包屑的位置： 右键行号区域 - Breadcrumbs - Top / Bottom 提示 Invalid classes root 几种可能的解决步骤，可以逐一尝试：  右键工程 - Run Maven - install -U，右键工程 - Run Maven - Reimport File - Project Structure - Libraries - 全选删除，Reimport 重启 IDEA 关闭 IDEA，将 .idea 目录删除，重新打开项目 自动生成 serialVersionUID 当一个类实现 Serializable 接口后，在 IDEA 里默认不会提示生成 serialVersionUID。 做如下配置之后可以实现提示：  Preferences - Editor - Inspections 搜索 Serializable class without ‘serialVersionUID’ 勾选该项并确定  提示效果： 配置打开/新建工程的默认 JDK 版本 打开/新建工程默认会使用比较新的 JDK，比如 JDK 11 或者 14。而在我的实际场景里一般还是需要用 JDK 8，这样每次都要手动设置很不方便。 设置默认 JDK 的方法： File &gt; New Projects Settings &gt; Structure For New Projects 忽略文件 Java 项目里有一些文件是不需要关注的，但它们默认会展示在 Project 视图，甚至会出现在你的搜索结果里，形成干扰。比如 dependency-reduced-pom.xml 和 target 文件夹等。 如何忽略掉它们呢？ Preferences &gt; Editor &gt; File Types &gt; Ignore Files and Folders，将文件/文件夹名称加进去，英文分号分隔。 修改查找的结果显示数量 默认显示 100 个查找结果，”100+ matches in X files”，而且无法翻页，所以想将 100 这个限制调大。 版本 &gt;= 2021.2 的：Settings &gt; Advanced Settings &gt; Maximum number of results to show in Find In Path/Show Usages preview 老版本：Help &gt; Find Action…Registry &gt; ide.usages.page.size，改成更大的值，比如 10000。 设置程序/测试用例运行的默认 VM Options 经常需要通过 VM Options 指定一些环境和配置相关的参数，每次有新的程序或者测试用例要执行时都要手动配置非常麻烦。 设置默认的 VM Options 方法： Run &gt; Edit Configurations &gt; Templates 点选你经常用到的 Template，比如 Spring Boot、JUnit、Tomcat Server &gt; Local，然后在 VM Options 里填上默认参数后保存。 无法 import 自己工程中类 File - Invalidate Caches 参考：https://zhuanlan.zhihu.com/p/341969427 隐藏 Coverage 结果 Run - Show Coverage Data 编译项目时报 java.lang.OutOfMemoryError: GC overhead limit exceeded java.lang.OutOfMemoryError: GC overhead limit exceeded 修改 IDEA 的 Custom VM Options 并没有用。 这是因为运行 IDEA App，和编译的程序，使用不同的 JVM 进程。 此时需要修改编译配置： Preferences - Build, Execution, Deployment - Compiler - Share build process heap size 默认是 700，我修改成了 4096，单位 Mbytes。 参考 https://intellij-support.jetbrains.com/hc/en-us/community/posts/206166909-java-lang-OutOfMemoryError-GC-overhead-limit-exceeded 更新时提示错误 IDEA does not have write access to /Application/IntelliJ IDEA.app/Contents. Please run it by a privileged user to update. 原因：最近切换过 MacBook 的用户，IDEA 是在老用户下安装的。 解决方法： 将 IntelliJ IDEA.app 目录的权限修改为当前用户。 sudo chown -R &lt;current_user&gt;:&lt;user_group&gt; /Application/IntelliJ IDEA.app 参考  解决IntelliJ IDEA无法读取配置*.properties文件的问题 How to build jars from IntelliJ properly? Can I adjust the “100+ matches in X files” from Intellijs “find in path” ",
      "url"      : "https://blog.shcat.top/wiki/intellij-idea/",
      "keywords" : "IDEA, Java"
    } ,
  
    {
      "title"    : "语言基础",
      "category" : "",
      "content": "Object 类的方法及用途 公有方法：  equals 用于对象间的比较。一般用于判断两个对象的内容是否相同。   getClass 返回类对象。   hashCode 返回对象的 hash code。一般在 HashSet、HashMap 和 HashTable 里会被调用到。 一些约定：   如果对象的 equals 方法做比较所用到的信息没有被修改，那对它多次调用 hashCode 方法返回的值应该相同。  如果两个对象调用 equals 方法返回 true，那么它们的 hashCode 方法应该返回相同的值。  如果两个对象调用 equals 方法返回 false，它们的 hashCode 方法不是必须返回不相同的值。但给不同对象返回不同 hash code 能提升散列表的性能。   notify 唤醒一个正在等待此对象的线程。   notifyAll 唤醒所有正在等待此对象的线程。   toString 返回该对象的字符串表示。   wait 让当前线程进入等待状态，直到另一个线程调用了该对象的 notify 或 notifyAll 方法。 保护方法：  clone 创建并返回该对象的拷贝。   finalize 垃圾收集器认为不存在该对象的引用后调用。 运算规则 如果对基本数据类型执行算术运行或按位运算，大家会发现，只要类型比 int 小（即 char、byte 或 short），那么在运算前，这些值都会自动转换成 int，这样一来，最终生成的结果就是 int 类型。如果想把结果赋值给较小的类型，就必须使用类型转换（既然把结果赋给了较小的类型，就可能出现信息丢失）。通常，表达式中出现的最大的数值决定了表达式最终的数据类型。如果将一个 float 值与一个 double 值相乘，结果就是 double，如果将一个 int 和一个 long 值相加，则结果为 long。 类型转换 float to int 四舍五入 i = Math.round(f); 示例结果：    float  int     2.0  2    2.22  2    2.68  3    -2.0  -2    -2.22  -2    -2.68  -3   相当于 (int) Math.floor(f + 0.5f)。 Math.round(float) returns a int, Math.round(double) returns a long. see http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html#round(double) 截取整数部分 i = (int) f; 示例结果：    float  int     2.0  2    2.22  2    2.68  2    -2.0  -2    -2.22  -2    -2.68  -2   向下取整 i = (int) Math.floor(f) 示例结果：    float  int     2.0  2    2.22  2    2.68  2    -2.0  -2    -2.22  -3    -2.68  -3   向上取整 i = (int) Math.ceil(f) 示例结果：    float  int     2.0  2    2.22  3    2.68  3    -2.0  -2    -2.22  -2    -2.68  -2   如何排除依赖包里的某一个类 用 Maven 管理依赖时，可以用 &lt;exclude&gt; 排除 jar 包维度的间接依赖，但是如果想要排除某一个类，如何处理？ 有一种方法是在项目里写一个同名类，如果不想要它，就把它写成空类，如果想修改它的行为，就重写这个类。 参考  How to convert float to int with Java ",
      "url"      : "https://blog.shcat.top/wiki/java-basis/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "Dubbo",
      "category" : "",
      "content": "知识点 命令行调用 示例： telnet localhost 50900 dubbo&gt; invoke test1(hello) dubbo&gt; invoke org.mazhuang.test1(hello) dubbo&gt; invoke org.mazhuang.test2(hello, {name:mzlogin, age: 18, class:org.mazhuang.Person}) 参考：https://dubbo.apache.org/zh/docs/references/telnet/#invoke 使用外网 IP 注册 Dubbo 默认使用主机名获取 IP。 Linux / Unix：通过 hostname 命令获取主机名。 在 /etc/hosts 里配置将主机名称映射到公网 IP。 参考：https://www.jianshu.com/p/b85ffd07bb38 常见问题 通过 XML 声明服务提供者 Bean 了，ServiceImpl 上还用加 @Service 注解吗？ 不用，再加 @Service 或 @Component 会生成两个 Bean。 ",
      "url"      : "https://blog.shcat.top/wiki/java-dubbo/",
      "keywords" : "Java, Dubbo"
    } ,
  
    {
      "title"    : "内部类",
      "category" : "",
      "content": "内部类的优点是：内部类可以访问外部类的私有成员变量，而不需要 new 外部类的对象。 内部类又分为：静态内部类、成员内部类、局部内部类和匿名内部类。 静态内部类：只可以访问外部类的静态成员变量和静态成员方法。 成员内部类：可以访问它的外部类的所有成员变量和方法，不管是静态的还是非静态的都可以。 局部内部类：像局部变量一样，不能被 public、private、protected 和 static 修饰，只能访问方法中定义为 final 类型的变量。 匿名内部类：匿名内部类就是没有名字的局部内部类，不使用关键字 class、extends 和 implements，没有构造方法。匿名内部类隐匿地继承了一个父类或者实现一个接口。匿名内部类使用得比较多，通常是作为一个方法参数。 参考  http://www.cnblogs.com/nerxious/archive/2013/01/24/2875649.html#3228810 ",
      "url"      : "https://blog.shcat.top/wiki/java-internal-class/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "JVM",
      "category" : "",
      "content": "本文内容主要摘抄自《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》。 GC 判断对象是否存活 引用计数算法 注：主流的 Java 虚拟机里没有选用引用计数算法来管理内存。 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器值就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。 但是它很难解决对象之间想要循环引用的问题，即两个对象只是相互持有对方的引用，但是实际它们都不会被访问到的情况。 可达性分析算法 基本思路是通过一系列的称为 GC Roots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连（即从 GC Roots 到这个对象不可达）时，则证明此对象不可用。 可作为 GC Roots 的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（如栈帧中的本地变量表）中。 在 Java 语言中，可作为 GC Roots 的对象包括下面几种：  虚拟机栈（栈帧中的本地变量表）中引用的对象。   方法区中类静态属性引用的对象。   方法区中常量引用的对象。   本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。 垃圾收集算法 标记-清除算法(Mark-Sweep) 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 不足：  效率。 标记和清除两个过程的效率都不高。   空间。 标记清除后会产生大量不连续的内存碎片。  图 1: 标记-清除算法示意图 复制算法(Copying) 将内存划分为两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上，然后将已使用过的内存空间一次清理掉。 不足：  可用内存变少。 HotSpot 中采用 Eden:Survivor:Survivor 比例 8:1:1 来划分空间，每次新生代可用80%+10%，当 Survivor 空间不够用时，需要依赖其它内存（这里指老年代）进行分配担保（Handle Promotion）。 图 2：复制算法示意图 标记-整理算法(Mark-Compact) 一般用于老年代。 先标记可清理对象，然后将存活对象向一端移动，再直接清理掉端边界以外的内存。 图 3：标记-整理算法示意图 分代收集算法(Generational Collection) 根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代。在新生代中，采用复制算法；在老年代中，使用标记-清除或标记-整理算法。 类加载机制 类的生命周期 加载（Loading）-连接（Linking）-初始化（Initialization）-使用（Using）-卸载（Unloading）。 其中连接（Linking）又可分为验证（Verification）-准备（Preparation）-解析（Resolution）三个阶段。 虚拟机规范严格规定了有且仅有 5 种情况必须立即进行类初始化：  遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，若类没有进行过初始化，则需要先触发其初始化。生成这 4 条指令的最常见的 Java 代码场景是：使用 new 关键字生成实例化对象时、读取或设置一个静态字段（被 final 修饰，已在编译期把结果放入常量池的静态字段除外）时，以及调用一个类的静态方法的时候。   使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。   当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。   当虚拟机启动时，用户需要指定一个要指定的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。   当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 以上 5 种场景中的行为称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用。比如：  通过子类引用父类的静态字段，不会导致子类初始化。   通过数组定义来引用类，不会触发此类的初始化。   常量（static final）在编译阶段会存入调用类的常量池中，本质中并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 准备阶段 准备阶段会正式为类变量分配内存并设置初始值，这些变量使用的内存都将在方法区中分配。这个阶段是初始化为零值，类构造器 &lt;clinit&gt; 方法在初始化阶段才会执行。若类变量为常量，此阶段会被初始化为指定的值。 初始化阶段 初始化阶段主要是执行 &lt;clinit&gt; 方法。该方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，语句顺序与源文件中出现顺序一致。 静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，可以赋值，但不能访问。 虚拟机会保证子类的 &lt;clinit&gt; 方法执行前，父类的 &lt;clinit&gt; 方法已经执行完毕。 接口的 &lt;clinit&gt; 方法不需要先执行父接口的 &lt;clinit&gt; 方法，只有当父接口中定义的变量被使用时才会初始化。 参考  《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》 ",
      "url"      : "https://blog.shcat.top/wiki/java-jvm/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "Lombok",
      "category" : "",
      "content": "Lombok 配合 Hibernate 注解实体类 主要是利用 @Getter 注解的 onMethod 属性，官方注释： /** * Any annotations listed here are put on the generated method. * The syntax for this feature depends on JDK version (nothing we can do about that; it's to work around javac bugs).&lt;br&gt; * up to JDK7:&lt;br&gt; * {@code @Getter(onMethod=@__({@AnnotationsGoHere}))}&lt;br&gt; * from JDK8:&lt;br&gt; * {@code @Getter(onMethod_={@AnnotationsGohere})} // note the underscore after {@code onMethod}. * * @return List of annotations to apply to the generated getter method. */ 示例： @Data @Entity @Table(name = t_user) public class User { @Getter(onMethod_ = {  @Id,  @GeneratedValue(strategy = GenerationType.IDENTITY),  @Column(name = id, unique = true, nullable = false)  })  private Long id; @Getter(onMethod_ = {  @Column(name = gmt_create)  })  private Timestamp gmtCreate; @Getter(onMethod_ = {  @Column(name = gmt_modified)  })  private Timestamp gmtModified; @Getter(onMethod_ = {  @Column(name = name)  })  private String name; @Getter(onMethod_ = {  @Column(name = status)  })  private Integer status; } ",
      "url"      : "https://blog.shcat.top/wiki/java-lombok/",
      "keywords" : "Lombok"
    } ,
  
    {
      "title"    : "Maven",
      "category" : "",
      "content": "问题与解决方案 deploy 时忽略指定模块 如果一个项目有如下结构： proj  -- proj-api  -- proj-service 那 mvn deploy 时会 deploy 三个目标：proj、proj-api、proj-service。 而实际上，我们往往只需要 deploy 前两者与其它项目共享，proj-service 只用于自己打包运行使用。 此时，可以在 proj-service 的 pom 文件里添加以下内容，这样 Maven 在 deploy 时会忽略掉 proj-service。 &lt;properties&gt;  &lt;maven.deploy.skip&gt;true&lt;/maven.deploy.skip&gt; &lt;/properties&gt; 打包成功启动失败 报错关键信息： Correct the classpath of your application so that it contains a single, compatible version of 可能的原因：包冲突，同一个类在包里有多个，加载了不正确的版本。 解决方法： 排除冲突包，只留一个版本。 如果有无法从 pom 里面排除的，则调整 pom 里的 dependency 顺序，将想要加载的那个放最上面。 参考  https://blog.csdn.net/rjbcxhc/article/details/123062310 ",
      "url"      : "https://blog.shcat.top/wiki/java-maven/",
      "keywords" : "Java, Maven"
    } ,
  
    {
      "title"    : "MyBatis-Plus",
      "category" : "",
      "content": "获取刚刚插入数据的主键 ID 如果我们使用数据库自增主键，可以通过给对应字段加上注解 @TableId(type = IdType.AUTO)，这样当 insert 后，刚刚插入数据的主键 ID 会回填到 id 字段上。 @Data public class User {  @TableId(type = IdType.AUTO)  private Long id; private String name; } 注解实现动态 SQL 不使用 mapper.xml 文件，在 @Mapper 注解的继承自 BaseMapper 的接口里，通过 @Select 等注解也可以实现动态 SQL。 这个属于 MyBatis 提供的功能。相关说明见官方文档：https://mybatis.org/mybatis-3/zh/dynamic-sql.html 一、使用 &lt;script&gt;&lt;/script&gt; 包裹，mapper.xml 里能使用的 &lt;where&gt;、&lt;if&gt;、&lt;foreach&gt;、&lt;set&gt; 等标签都可以使用，用法看起来与在 xml 里一致； 二、使用 if (条件，为真操作，为假操作) 可以实现类三目运算； 参考：  https://mybatis.org/mybatis-3/zh/dynamic-sql.html https://www.jianshu.com/p/eee6832628ce 字段 on update CURRENT_TIMESTAMP 无效 如果 update 操作中 set 了该字段，比如很多时候我们用 updateById 等，不会触发。 可以添加注解 @TableField(update = NOW())。 注：添加了这个注解后，如果 insert 时对应的字段赋值了，会按所赋的值存储。 查询时 distinct List&lt;User&gt; userList = userService.list(new QueryWrapper&lt;User&gt;()  .select(distinct id).lambda().isNull(User::getName)); ",
      "url"      : "https://blog.shcat.top/wiki/java-mybatis-plus/",
      "keywords" : "Java, MyBatis-Plus"
    } ,
  
    {
      "title"    : "多线程",
      "category" : "",
      "content": "线程同步机制 synchronized 关键字 可以用于同步方法与同步代码块，是可重入的。  静态方法是使用 class 对象作为对象锁。   非静态方法是使用 this 对象作为对象锁。（所以多个对象的 synchronized 方法是可以同时执行的）   synchronized 实现的锁是可重入锁。 java.util.concurrent.lock 包中的 Lock 对象 ReetrantLock 提供了 synchronized 相关的并发性和内存主义，但是添加了类投票、定时锁等候和可中断锁等。激烈竞争下有更好的性能。 CountDownLatch 线程池 使用线程池的好处  重用线程，避免线程的频繁创建销毁带来的性能开销。   能有效控制最大并发数，避免大量线程争抢资源而造成阻塞。   能够对线程进行简单的管理，并提供定时执行及间隔循环执行等功能。 线程池的分类  FixedThreadPool 只有核心线程，并且它们不会被回收。任务队列没有大小限制。   CachedThreadPool 线程数量不固定，只有非核心线程，任何任务都会被立即执行。当线程池中的线程都处于活动状态时，线程池会创建新的线程来处理任务，否则就会利用空闲线程。线程闲置超过 60 秒就会被回收。 适合执行大量的、耗时较少的任务。   ScheduledThreadPool 核心线程数量固定，非核心线程数没有限制。非核心线程闲置即被回收。 适合用于执行定时任务和具有固定周期的重复任务。   SingleThreadExecutor 只有一个核心线程，它的意义在于统一所有的任务到一个线程。 获取线程堆栈 获取本进程内所有活动线程的堆栈： private String getAllStackTraces() {  Map&lt;Thread, StackTraceElement[]&gt; stacks = Thread.getAllStackTraces();  StringBuilder sb = new StringBuilder();  for (Thread key : stacks.keySet()) {  StackTraceElement[] stackTraceElements = stacks.get(key);  sb.append(  thread ).append(key.getName());  for (StackTraceElement st : stackTraceElements) {   sb.append(    t).append(st.toString());  }  } return sb.toString(); } ",
      "url"      : "https://blog.shcat.top/wiki/java-threads/",
      "keywords" : "Android"
    } ,
  
    {
      "title"    : "开发工具箱",
      "category" : "",
      "content": "数据库 连接池  Druid 持久层  mybatis MyBatis-Plus 动态数据源  dynamic datasource for springboot 配置中心  Apollo Nacos ",
      "url"      : "https://blog.shcat.top/wiki/java-toolbox/",
      "keywords" : "Java, 工具箱"
    } ,
  
    {
      "title"    : "Kindle 屏保图片",
      "category" : "",
      "content": "Content here ",
      "url"      : "https://blog.shcat.top/wiki/kindle-screensavers/",
      "keywords" : "kindle, Screensavers, Paperwhite"
    } ,
  
    {
      "title"    : "Kindle",
      "category" : "",
      "content": "越狱资源  Kindle Paperwhite 1 代越狱教程 Kindle 越狱资源及插件下载详细步骤 用插件 BookFere Tools 清理无用 sdr 文件夹 问题解决 切换亚马逊账号导致 Kindle Launcher 无法打开 提示语类似「您的设备不再被授权为开发设备」之类的，但 KOReader、KPVBooklet 和 ScreenSaver 等插件工作正常，推测越狱没有失效，只是 KUAL 相关的这个 Kindle Launcher 打不开了。 解决方法：  点击一个 PDF 文件打开 KOReader； 进入文件浏览器，找到 /mnt/us/mkk/developer.keystore，长按复制； 进到 /var/local/java/keystore 目录，长按粘贴； 重启 Kindle。 注：第 2 步进到 /mnt/us/mkk 路径下有可能发现看不到 developer.keystore 文件，此时在 KOReader 的菜单项里找到「设置」-「显示不支持的文件」，将其勾选即可。 KPVBooklet 安装后无法在主页直接打开 PDF 和 EPUB 文件 KPVBooklet 最新版 v0.66 安装到 Kindle Paperwhite 1 代 5.6.1.1 固件会出现此问题，点击 PDF 文件提示「无法启动选定的应用程序」。 解决方法： 到官网仓库 https://github.com/koreader/kpvbooklet/releases 下载安装 v0.6.4 版本可正常工作。看 Issue #46 里的讨论，是 v0.6.5 和 v0.6.6 换了打包的人员，有可能使用的 JDK 版本等有差异导致的。 ",
      "url"      : "https://blog.shcat.top/wiki/kindle/",
      "keywords" : "Kindle"
    } ,
  
    {
      "title"    : "Linux/Unix",
      "category" : "",
      "content": "类 Unix 系统下的一些常用命令和用法。 实用命令 chown 更改文件所有者和组。 比如某文件夹当前所有者是 root，需要更改为 admin： chown -R admin:admin test chmod 修改文件权限。 fuser 查看文件被谁占用。 fuser -u .linux.md.swp id 查看当前用户、组 id。 lsof 查看打开的文件列表。  An open file may be a regular file, a directory, a block special file, a character special file, an executing text reference, a library, a stream or a network file (Internet socket, NFS file or UNIX domain socket.) A specific file or all the files in a file system may be selected by path. 查看网络相关的文件占用 lsof -i 查看端口占用 lsof -i tcp:5037 查看某个文件被谁占用 lsof .linux.md.swp 查看某个用户占用的文件信息 lsof -u mazhuang -u 后面可以跟 uid 或 login name。 查看某个程序占用的文件信息 lsof -c Vim 注意程序名区分大小写。 ",
      "url"      : "https://blog.shcat.top/wiki/linux/",
      "keywords" : "Linux"
    } ,
  
    {
      "title"    : "Mac OS X",
      "category" : "",
      "content": "快捷键约定： C –&gt; Ctrl S –&gt; Shift M –&gt; Alt/Option Cmd –&gt; Command Mac 键盘快捷键官方参考 窗口    功能  快捷键     显示桌面  F11    上/下一个桌面/工作区  C-Left/Right    切换窗口全屏状态  C-Cmd-F    隐藏当前程序的所有窗口  Cmd-H    最小化窗口  Cmd-M    关闭窗口  Cmd-W    关闭当前程序  Cmd-Q    新建标签  Cmd-T    新建窗口  Cmd-N    调度中心  C-Up    当前应用的所有窗口  C-Down   程序    功能  快捷键     打开 emoji 表情窗口  C-Cmd- 空格    打开 Spotlight  C- 空格    切换输入法  Cmd- 空格    打开 Alfred  M- 空格    打开 Finder 并查找  C-M- 空格    打开 Launchpad  四指合拢   音量    功能  快捷键     微调音量  M-S-音量加/音量减   命令行 快捷键    功能  按键     移动光标至行首  C-a    移动光标至行尾  C-e    清屏  C-l    删除光标前的所有文字。如果光标位于行尾则删除整行。  C-u    与退格键相同  C-h    检索使用过的命令  C-r    终止当前执行  C-c    退出当前 shell  C-d    将执行中的任何东西放入后台进程。fg 可以将其恢复。  C-z    删除光标之前的单词  C-w    删除光标后的所有文字  C-k    将光标前的两个文字进行互换  C-t    光标向前移动一个单词  C-f    光标向后移动一个单词  C-b    将光标前的两个单词进行互换  Esc + t    自动补全文件或文件夹的名称  Tab   命令    按键 / 命令  描述     cd  Home 目录    cd [folder]  切换目录    cd ~  Home 目录，例如 ‘cd ~/folder/’    cd /  根目录    ls  文件列表    ls -l  文件详细列表    ls -a  列出隐藏文件    ls -lh  文件详细列表中的文件大小以更友好的形式列出    ls -R  递归显示文件夹中的内容    sudo [command]  以超级用户身份执行命令    open [file]  打开文件 ( 相当于双击一个文件 )    top  显示运行中的进程，按 q 终止    nano [file]  打开编辑    pico [file]  打开编辑    q  退出    clear  清屏   命令历史    按键/命令  描述     history n  列出最近执行过的 n 条命令    ctrl-r  检索之前执行过的命令    ![value]  执行最近以 ‘value’ 开始的命令    !!  执行最近执行过的命令   文件管理    按键/命令  描述     Cmd-Shift-.  显示/恢复隐藏文件    touch [file]  创建一个新文件    pwd  显示当前工作目录    ..  上级目录, 例如.    ‘ls -l ..’  上级目录的文件详细列表    ‘cd ../../’  向上移动两个层级    .  当前目录    cat  连接    rm [file]  移除文件, 例如 rm [file] [file]    rm -i [file]  移除时出现确认提示    rm -r [dir]  移除文件及内容    rm -f [file]  强制移除    cp [file] [newfile]  复制文件    cp [file] [dir]  复制文件到指定目录    mv [file] [new filename]  移动 / 重命名, 例如 mv -v [file] [dir]   目录管理    按键/命令  描述     mkdir [dir]  创建新目录    mkdir -p [dir]/[dir]  创建子目录    rmdir [dir]  移除目录 ( 仅限目录下没有内容时 )    rm -R [dir]  移除目录及内容   管道 - 连接多个带有输出的命令    按键/命令  描述     more  按当前窗口大小输出内容    &gt; [file]  输出至指定文件, 注意文件将会覆盖    » [file]  在制定文件的末尾附加内容    &lt;  从文件中读取内容   帮助    按键/命令  描述     [command] -h  显示帮助信息    [command] –help  显示帮助信息    [command] help  显示帮助信息    reset  重置当前终端    man [command]  显示指定命令的帮助信息    whatis [command]  显示指定命令的简述   搜索  使用 find 命令，例如： find ~ -iname aapt   使用 mdfind 命令，例如： 全局搜索 mdfind -name aapt   或搜索指定文件夹 mdfind -onlyin ~/Library aapt   使用 locate 命令，例如： locate aapt   复制文件路径  在 Finder 下 先按键 Cmd-i，然后从弹出的窗口里复制。   在 Terminal 下 pwd|pbcopy   Safari    功能  快捷键     定位到地址栏  Cmd-L    切换标签  Cmd-S-Left/Right    收藏页面  Cmd-D   保存 Safari 里正在播放的视频 $ su # cd /private/var/folders # ls nk zz # cd nk # ls zy3770994vqg83xvmbc9pd0m0000gn # cd zy3770994vqg83xvmbc9pd0m0000gn/T # open . 然后复制里面叫 FlashTmp.xxx 的文件，改名为 FlashTmp.flv。（操作过程中保持视频在播放状态） 打开 Axure 导出文件  Safari 浏览器 - 偏好设置 - 高级 - 勾选「在菜单栏中显示开发菜单」； 展开「开发」菜单，勾选「停用本地文件限制」； 再将 Axure 导出文件的 index.html 使用 Safari 打开就好了。 Terminal    功能  快捷键     新建标签  Cmd-T    上 / 下个标签  Cmd-{/}    删除光标前的输入  C-U   WireShark 使用 WireShark 1.99 开发版，可以不依赖于 X11，界面基于 Qt，更加美观，符合 Mac 界面风格。 截图    功能  快捷键     全屏截图保存到桌面  Cmd-S-3    全屏截图并复制  Cmd-C-S-3    选区截图保存到桌面  Cmd-S-4    选区截图并复制  Cmd-C-S-4    窗口截图保存到桌面  Cmd-S-4 空格    窗口截图并复制  Cmd-C-S-4 空格    QQ 截图  Cmd-S-A   去除窗口截图时的阴影 defaults write com.apple.screencapture disable-shadow -bool TRUE Killall SystemUIServer 如果要保留窗口截图时的阴影，则将 TRUE 改为 FALSE。 调整选区大小 使用选区模式选中一个区域并松开鼠标前，  按住空格并移动鼠标，可以保持区域大小不变，并移动区域； 按住Shift并移动鼠标，就可以保持区域的其它三个边不变，移动一个边的位置； 按住Alt并移动鼠标，就可以对称的调整区域大小。 截图标注 使用预览工具可以完成截图标注。 延时截图 使用系统自带的 Grab 工具，运行后选择菜单的 Capture - Timed Screen。 iBooks 里的电子书保存路径 /Users/&lt;username&gt;/Library/Containers/com.apple.BKAgentService/Data/Documents/iBooks/Books 安装 mpv 没有图形界面 使用 brew options mpv 可以看到有个 --with-bundle 是安装时创建 .app 文件。 brew install mpv --with-bundle brew linkapps mpv 屏幕取色 使用 Mac 自带的“数码测色计”。 小技巧 程序坞延迟消除 Mac 自动隐藏/显示程序坞是默认有一秒延迟的。 消除延迟方法： defaults write com.apple.Dock autohide-delay -float 0 &amp;&amp; killall Dock 恢复默认： defaults delete com.apple.Dock autohide-delay &amp;&amp; killall Dock 修改默认 shell chsh -s /bin/zsh 问题解决 No Xcode or CLT version detected 报错信息： ~/github/hs-airdrop$ npm install &gt; bcrypto@5.0.3 install /Users/username/github/hs-airdrop/node_modules/bcrypto &gt; node-gyp rebuild No receipt for 'com.apple.pkg.CLTools_Executables' found at '/'. No receipt for 'com.apple.pkg.DeveloperToolsCLILeo' found at '/'. No receipt for 'com.apple.pkg.DeveloperToolsCLI' found at '/'. gyp: No Xcode or CLT version detected! gyp ERR! configure error gyp ERR! stack Error: `gyp` failed with exit code: 1 gyp ERR! stack  at ChildProcess.onCpExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/configure.js:351:16) gyp ERR! stack  at ChildProcess.emit (events.js:210:5) gyp ERR! stack  at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12) gyp ERR! System Darwin 19.3.0 gyp ERR! command /usr/local/Cellar/node/12.12.0/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js rebuild gyp ERR! cwd /Users/username/github/hs-airdrop/node_modules/bcrypto gyp ERR! node -v v12.12.0 gyp ERR! node-gyp -v v5.0.5 gyp ERR! not ok npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! bcrypto@5.0.3 install: `node-gyp rebuild` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the bcrypto@5.0.3 install script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. 解决方法： sudo xcode-select -s /Applications/Xcode.app/Contents/Developer 通过扩展坞连接的键盘鼠标卡顿断电 我用 MacBook Pro 16 寸 2019 款，通过 biaze 五口扩展坞连接键盘、鼠标、显示器、网线，一直好好的，突然有一天键盘鼠标开始经常卡顿、断电。参考 https://support.apple.com/zh-cn/HT201295，重置 SMC 问题也没有解决。 尝试过插别的接口、换扩展坞、只接以上几种设备之一和之二等，都没解决。最后用了个别的鼠标试了下，好了。欲哭无泪。 macOS 12.4 Monterey 系统授权弹窗无法点击 自从电脑从本地账号切换到域账号之后，这个系统版本里经常一个程序用着用着，突然弹出个系统授权弹窗，申请访问文件夹、摄像头、麦克风、屏幕录制、System Events 等等，然后弹窗里的两个按钮点击无效，程序就卡在那里了。 比如下面这个弹窗： 解决方法：  打开「活动监视器」，结束掉 UserNotificationCenter 进程；    打开「系统偏好设置」-「安全性与隐私」，找到刚才提示的对应权限和应用，把左下角的锁打开后，勾选上；  删除 zip 文件里的隐藏文件 使用 Mac 自带的压缩功能，打出来的 zip 包里面会打入像 .DS_Store 和 __MACOSX 这些东西，在有些场景下需要将它们清除。 这时，可以使用以下命令： zip -d 归档.zip __MACOSX* zip -d 归档.zip *.DS_Store 或者，创建一个如下内容的 cleanzip.sh 文件，放到 PATH 环境变量包含的路径里面，然后在需要时执行 cleanzip 归档.zip 即可： zip -d $1 __MACOSX* zip -d $1 *.DS_Store 参考  你可能不知道的 Mac 技巧 - 截图，Gif 制作及 App 推荐 terminal-mac-cheatsheet macOS 12.4 系统弹窗无法点点击 SimulatorTrampoline.xpc 无法授权 如何取消macOS压缩时生成的「_MACOSX」的隐藏文件夹？ - 知乎 ",
      "url"      : "https://blog.shcat.top/wiki/mac/",
      "keywords" : "Mac"
    } ,
  
    {
      "title"    : "Markdown Intro",
      "category" : "",
      "content": "Content here ",
      "url"      : "https://blog.shcat.top/wiki/markdown-intro/",
      "keywords" : "markdown"
    } ,
  
    {
      "title"    : "Markdown",
      "category" : "",
      "content": "目录  超链接 列表 强调 标题 表格 代码块 图片 锚点 Inline Attribute Emoji Footnotes mermaid sequence flowchart mathjax mindmap 超链接 [靠谱-ing](https://mazhuang.org) &lt;https://mazhuang.org&gt; 靠谱-ing https://mazhuang.org 列表 1. 有序列表项 1 2. 有序列表项 2 3. 有序列表项 3   有序列表项 1   有序列表项 2   有序列表项 3 * 无序列表项 1 * 无序列表项 2 * 无序列表项 3   无序列表项 1   无序列表项 2   无序列表项 3 - [x] 任务列表 1 - [ ] 任务列表 2 任务列表 1 任务列表 2 强调 ~~删除线~~ **加黑** *斜体* 删除线 加黑 斜体 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 Tips: # 与标题中间要加空格。 表格 | HEADER1 | HEADER2 | HEADER3 | HEADER4 | | ------- | :------ | :-----: | ------: | | content | content | content | content |   HEADER1  HEADER2  HEADER3  HEADER4     content  content  content  content   :—– 表示左对齐 :—-: 表示中对齐 —–: 表示右对齐 代码块 print 'Hello, World!'   list item1   list item2 print 'hello'   图片 ![本站favicon](/favicon.ico)  锚点 * [目录](#目录) 目录 Inline Attribute Span Inline Attribute 详情参考 https://kramdown.gettalong.org/syntax.html#span-ials Block Inline Attribute 详情参考 https://kramdown.gettalong.org/syntax.html#block-ials 给块/元素添加 class、id、内嵌样式等： ![本站favicon](/favicon.ico){:.center} Hello, *world*{:#world} Hello, *world*{: style=color:red} Hello, world Hello, world 结合自定义的样式，有些场景比较有用。 Emoji :camel: :blush: :smile: Footnotes This is a text with footnote1. mermaid sequenceDiagram  Alice--&gt;&gt;John: Hello John, how are you?  John--&gt;&gt;Alice: Great! sequence Andrew-&gt;China: Says Hello Note right of China: China thinks  about it China--&gt;Andrew: How are you? Andrew-&gt;&gt;China: I am good thanks! flowchart st=&gt;start: Start e=&gt;end op1=&gt;operation: My Operation sub1=&gt;subroutine: My Subroutine cond=&gt;condition: Yes or No? io=&gt;inputoutput: catch something... st-&gt;op1-&gt;cond cond(yes)-&gt;io-&gt;e cond(no)-&gt;sub1(right)-&gt;op1 mathjax When   ((a   e 0)  ), there are two solutions to   ((ax^2 + bx + c = 0)  ) and they are [x = {-b   pm   sqrt{b^2-4ac}   over 2a}.] mindmap # topic ## topic2 ### topic2.1 ### topic2.2 ## topic3 &lt;!--Note--&gt; 这是一个备注 &lt;!--/Note--&gt; ### topic3.1 ### topic3.2 #### topic3.2.1 #### topic3.2.2 #### topic3.2.3 #### topic3.2.4 #### topic3.2.5 ### topic3.4 ### topic3.5 ### topic3.6   Here is the footnote 1 definition. &#8617;  ",
      "url"      : "https://blog.shcat.top/wiki/markdown/",
      "keywords" : "Markdown"
    } ,
  
    {
      "title"    : "MPV",
      "category" : "",
      "content": "Mac OS X 下最好用的播放器，没有之一。 快捷键 参考：mpv keybindings    按键  功能     RIGHT  前进 5 秒    LEFT  后退 5 秒    UP  前进 60 秒    DOWN  后退 60 秒    [  0.9091 倍速播放    ]  1.1 倍速播放    {  0.5 倍速播放    }  2.0 倍速播放    Backspace  还原到 1.0 倍速    Space 或 p  播放/暂停    .  下一帧    ,  上一帧    9 或 /  音量 -2    0 或 *  音量 +2    f  切换是否全屏    v  显示/隐藏字幕    T  切换是否前端显示    s  截屏，有字幕    S  截屏，无字幕    o  显示进度条与时间，2 秒后消失    I (大写 i)  显示当前文件名    1  对比度 -1    2  对比度 +1    3  亮度 -1    4  亮度 +1    5  Gamma 值 -1    6  Gamma 值 +1    7  饱和度 -1    8  饱和度 +1    l (小写 L)  设置/清除 A-B 循环点    j/J  选择字幕    #  切换声道    q  退出   命令行参数 参考：OPTIONS 参考  MPV使用小记 ",
      "url"      : "https://blog.shcat.top/wiki/mpv/",
      "keywords" : "mpv"
    } ,
  
    {
      "title"    : "MySQL",
      "category" : "",
      "content": "使用 启动与停止 macOS mysql.server start mysql.server stop mysqladmin -u root -p shutdown mysql -u root -p Windows（使用管理员权限的 CMD） net start mysql net stop mysql 连接 mysql -u 用户名 -p密码 -h 服务器IP地址 -P 服务器端MySQL端口号 -D 数据库名 授权 授权远程登录 grant 权限1,权限2,…权限n on 数据库名称.表名称 to 用户名@用户地址 identified by '连接口令'; 修改密码 方法1： 用SET PASSWORD命令 mysql -u root mysql&gt; SET PASSWORD FOR 'root'@'localhost' = PASSWORD('newpass'); 方法2：用 mysqladmin mysqladmin -u root password newpass 如果root已经设置过密码，采用如下方法 mysqladmin -u root password oldpass newpass 方法3： 用UPDATE直接编辑user表 mysql -u root mysql&gt; use mysql; mysql&gt; UPDATE user SET Password = PASSWORD('newpass') WHERE user = 'root'; mysql&gt; FLUSH PRIVILEGES; 在丢失root密码的时候，可以这样 mysqld_safe --skip-grant-tables&amp; mysql -u root mysql mysql&gt; UPDATE user SET password=PASSWORD(new password) WHERE user='root'; mysql&gt; FLUSH PRIVILEGES; 命令行执行脚本 mysql -u root -p111111 -Dtest &lt; test.sql 其它问题 MySQL 5.7 在 Windows 下安装后无法直接运行，需要步骤：  mysqld install mysqld –initialize-insecure 自动生成无密码的 root 用户或 mysqld –initialize 自动生成带随机密码的 root 用户 net start mysql Mysql -u root 常用 SQL 查看 -- 查看表的创建语句 desc tb_name; show create table tb_name; -- 查看表的索引 show index from table_name; 修改 -- 修改列属性 alter table tb_name modify column_name int auto_increment; （如果是修改主键，不能带 primary key，不然会报 ERROR 1068 (42000): Multiple primary key defined） dump -- dump 库 mysqldump -u root -p db_name &gt; 1.txt -- dump 表 mysqldump -u root -p db_name tb_name &gt; 1.txt -- dump 表不带数据 mysqldump -u root -p --no-date db_name tb_name &gt; 1.txt 数据库状态 show engine INNODB status; 脏页相关 -- flush 脏页时是否刷新邻居 show VARIABLES like 'innodb_flush_neighbors'; -- 设置该值 set global innodb_flush_neighbors = 0; -- 查看脏页比例 select VARIABLE_VALUE into @a from PERFORMANCE_SCHEMA.global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty'; select VARIABLE_VALUE into @b from PERFORMANCE_SCHEMA.global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total'; select @a/@b; 磁盘空间相关 查看数据库内磁盘占用空间： SELECT table_name,  TABLE_SCHEMA,  ( DATA_LENGTH + INDEX_LENGTH + DATA_FREE ) / 1024 / 1024 MB,  TABLE_ROWS  FROM  information_schema. TABLES  WHERE  TABLE_SCHEMA NOT IN ('information_schema','mysql')  ORDER BY  MB DESC  LIMIT 0,  50 查看表中数据、索引、已分配给表但没有使用空间： SELECT table_name,  TABLE_SCHEMA,  DATA_LENGTH/ 1024 / 1024 _DATA, INDEX_LENGTH/ 1024 / 1024 _INDEX, DATA_FREE/ 1024 / 1024 _DATA_FREE,  TABLE_ROWS  FROM  information_schema. TABLES  WHERE  TABLE_SCHEMA NOT IN ('information_schema','mysql')  ORDER BY  _DATA DESC  LIMIT 0,  50 查看数据库的文件大小： SELECT file_name, concat(TOTAL_EXTENTS,'M') as 'FIle_size' FROM INFORMATION_SCHEMA.FILES order by TOTAL_EXTENTS DESC 阻塞问题排查/解决 -- 查看有哪些表是打开的 show open tables -- where in_use &gt; 0; -- 查看进程 show [full] processlist; -- 查看 Sending data 状态的进程 select * from information_schema.`PROCESSLIST` where db = 'db_name' and state = 'Sending data' order by time desc; -- 批量生成 kill &lt;pid&gt;; 语句 select concat(kill , id, ;) from information_schema.`PROCESSLIST` where db = 'db_name' and state = 'Sending data' order by time desc; -- 批量生成 kill &lt;pid&gt;; 语句并将结果集写到文件 select concat(kill , id, ;) from information_schema.`PROCESSLIST` where db = 'db_name' and state = 'Sending data' order by time desc into outfile '/tmp/a.txt'; -- 执行文件 source /tmp/a.txt -- 杀掉指定进程 kill &lt;pid&gt;; -- 查看正在锁的事务 select * from information_schema.INNODB_LOCKS; -- 查看等待的事务 select * from information_schema.INNODB_LOCK_WAITS; -- 查看线程相关数量 show global status like 'Thread%' -- 查看缓存线程数配置 show VARIABLES like 'thread_cache_size' SQL 技巧 -- 在原值后面附加内容，以值的最右几位为条件 update table_name set col1 = concat(col1, 'xxx') where right(col1, 1) = '?'; -- limit 示例 SELECT * FROM Orders LIMIT 30; SELECT * FROM Orders LIMIT 10 OFFSET 15; -- 第 16 到第 25 个结果 SELECT * FROM Orders LIMIT 15, 10; -- 等价于上面 ",
      "url"      : "https://blog.shcat.top/wiki/mysql/",
      "keywords" : "MySQL"
    } ,
  
    {
      "title"    : "OllyDbg",
      "category" : "",
      "content": "快捷键 Ctrl –&gt; C Shift –&gt; S Alt –&gt; M    功能  快捷键     设置/取消断点  F2    执行到光标所在行  F4    步过  F8    步进  F7    运行  F9    暂停  F12    回到应用层  M-F9    打开文件  F3    重新调试  C-F2    打开应用程序输入表  C-n    寻找表达式  C-g    打开断点窗口  M-b    切换断点状态  空格    添加备注  ;  ",
      "url"      : "https://blog.shcat.top/wiki/ollydbg/",
      "keywords" : "debug, ollydbg"
    } ,
  
    {
      "title"    : "OneNote",
      "category" : "",
      "content": "快捷键 C –&gt; Ctrl S –&gt; Shift M –&gt; Alt Cmd –&gt; Command 调整文本格式    功能  Windows  Mac OS X     高亮选中文本  C-S-h 或 C-M-h       插入超链接  C-k  Cmd-k    复制选中文本的格式（格式刷）  C-S-c  Cmd-M-c    应用格式刷到选中文本  C-S-v  Cmd-M-v    打开光标下的链接  Enter  Enter    加黑  C-b  Cmd-b    斜体  C-i  Cmd-i    下划线  C-u  Cmd-u    删除线  C-Hyphen(-)  C-Cmd-Hyphen(-)    上标  C-S-=  Cmd-M-S-=    下标  C-=  Cmd-M-=    无序列表标记  C-Period(.)  Cmd-Period(.)    有序列表标记  C-Slash(/)  Cmd-Slash(/)    标题一  C-M-1  Cmd-M-1    标题六  C-M-6  Cmd-M-6    正文，清除格式  C-S-n  Cmd-S-n    增加段落缩进  M-S-Right  Cmd-]    减少段落缩进  M-S-Left  Cmd-[    左对齐  C-l  Cmd-l    右对齐  C-r  Cmd-r    增大选中文本字体  C-S-&gt;       减小选中文本字体  C-S-&lt;       在当前页面显隐基准线  C-S-r      视图    功能  Windows  Mac OS X     显示/隐藏功能区     Cmd-M-R    放大页面     Cmd-+    缩小页面     Cmd-Hyphen(-)    重置缩放     Cmd-0   插入元素    功能  Windows  Mac OS X     插入日期  M-S-d  Cmd-d    插入时间  M-S-t       插入日期+时间  M-S-f  Cmd-S-d   注：在 Windows 下插入的日期格式取决于系统的「日期、时间和区域格式设置」里的设置。 表格    功能  Windows  Mac OS X     在当前行下面新建行  C-Enter  Cmd-Enter    在当前行上面新建行  光标移到行首，Enter  光标移到行首，Enter    在当前列右边新建列  C-M-r  C-Cmd-r    在当前列左边新建列     C-Cmd-l    在当前单元格开始新段落  M-Enter  M-Enter   选择与移动    功能  Windows  Mac OS X     移动光标到页面标题并选中  C-S-t  Cmd-S-t    将段落上移  M-S-Up  Cmd-M-Up    将段落下移  M-S-Down  Cmd-M-Down    返回上一个访问过的页面  M-Left  C-Cmd-Left    前进到后一个访问过的页面  M-Right  C-Cmd-Right    到页面顶端     Cmd-Up    到页面底端     Cmd-Down    到上一个段落     M-Up    到下一个段落     M-Down   分区与页面    功能  Windows  Mac OS X     新建页面到当前分区最后面  C-n  Cmd-n    在当前页面下新建同级页面  C-M-n  Cmd-n    在当前页面下新建子页面  C-M-S-n       增加页面层级  C-M-]  Cmd-M-]    减少页面层级  C-M-[  Cmd-M-[    选中当前页面  C-M-g  Cmd-S-a    上移当前选中页面  M-S-Up  Cmd-M-Up    下移当前选中页面  M-S-Down  Cmd-M-Down    返回访问的上一页  M-Left  C-Cmd-Left    返回访问的下一页  M-Right  C-Cmd-Right    停靠到桌面  C-M-d       显示上一个分区  C-S-Tab       显示下一个分区  C-Tab       显示当前分区的上一个页面  C-Page Up  Cmd-Page Up    显示当前分区的下一个页面  C-Page Down  Cmd-Page Down    显示当前分区的第一个页面  M-Home  M-Home    显示当前分区的最后一个页面  M-End  M-End   小技巧  搜索带特殊字符如「空格」等，用 将搜索关键字括起来。   删除「我的模板」 在 Windows 下的 C:  Users  &lt;username&gt;  AppData  Roaming  Microsoft  Templates 里找到文件 我的模板.one，双击打开将显示你所有的模板页面，删除你想要删除的然后关闭即可。 参考  OneNote 2010 的键盘快捷键 Keyboard shortcuts in OneNote for Windows 10 ",
      "url"      : "https://blog.shcat.top/wiki/onenote/",
      "keywords" : "OneNote, GTD"
    } ,
  
    {
      "title"    : "企业微信",
      "category" : "",
      "content": "企业微信开发过程中的一些知识点记录。 问题及解决方案 redirect_uri需使用应用可信域名 遇到过两种情况出现这个提示。 一、环境搞混了，应用主页使用构造的 OAuth2 链接，其中的 appid 与 redirect_uri 里的域名不对应。 比如正在配置 UAT 环境应用，但是将 FAT 环境应用的 OAuth2 链接复制过来之后，忘了修改 appid，只修改了链接中的域名，遇到该问题，后来将 appid 修改成 UAT 环境应用的就正常了。 二、修改了可信域名之后，出现该提示。 修改了 UAT 环境应用（未在企业微信提交上线）的可信域名之后，遇到了该提示，因为是测试环境，直接将测试安装的企业删除后重新测试安装，就正常了。 但修改了生产环境应用（已在企业微信提交上线）的可信域名之后，一直是该提示，清除手机上的企业微信缓存，杀应用进程等都无效，点击应用主页还是一直跳旧链接。最后搜索到这个链接：企业微信开发中，可信域名可以修改吗？，官方回复为：  你好，可以修改，第三方应用修改可信域名，没上线的需要重新授权，已上线的需要重新提交审核，才会生效。 将应用在企业微信服务商管理后台提交上线审核通过后恢复正常。 企业微信回调报 Base64 错误 具体报错信息： java.lang.IllegalArgumentException: Last encoded character (before the paddings if any) is a valid base 64 alphabet but not a possible value. Expected the discarded bits to be zero.  tat org.apache.commons.codec.binary.Base64.validateCharacter(Base64.java:803)  tat org.apache.commons.codec.binary.Base64.decode(Base64.java:482)  tat org.apache.commons.codec.binary.BaseNCodec.decode(BaseNCodec.java:481)  tat org.apache.commons.codec.binary.BaseNCodec.decode(BaseNCodec.java:465)  tat org.apache.commons.codec.binary.Base64.decodeBase64(Base64.java:699)  tat com.qq.weixin.mp.aes.WXBizMsgCrypt.&lt;init&gt;(WXBizMsgCrypt.java:63) 在网上找到一个记录相同报错的链接：https://blog.csdn.net/qq_36830575/article/details/106646545 最终确认确实是由于项目依赖的 commons-codec 包被升级到 1.13 以上（我们是升到了 1.14），导致 EncodingAESKey 解码失败。我采用了不同于上面那个链接的另一种解决办法，将 WXBizMsgCrypt 里的 Base64.decodeBase64 改为了 Base64Utils.decodeFromString，其中 Base64Utils 是 Spring 自带的工具类，经测试可以正常兼容。 更进一步的原因，大致意思是 commons-codec Base64 在解码时，面对非法的输入（比如最后的几个补位应该都是 0，但是混入了 1）的情况，应该拒绝，但老版本还是尝试给它解码了一个结果出来，而这个解码后的结果再次编码会生成另一个值，这可能会产生安全漏洞。 相关讨论见：  https://issues.apache.org/jira/browse/CODEC-134 https://issues.apache.org/jira/browse/CODEC-270 https://issues.apache.org/jira/browse/CODEC-279 参考链接  企业微信开发中，可信域名可以修改吗？ 关于网页授权的可信域名 ",
      "url"      : "https://blog.shcat.top/wiki/open-wxwork/",
      "keywords" : "企业微信"
    } ,
  
    {
      "title"    : "PHP",
      "category" : "",
      "content": "Q &amp; A 如何查看 php.ini 文件路径？ 新建一个 test.php 文件，内容如下： &lt;?php phpinfo(); ?&gt; 然后在浏览器使用 url 访问 test.php，会显示 php 相关的配置、插件等大量相关信息，在其中 Loaded Configuration File 一项即可找到所有生效的 php.ini 文件路径。 或者，更简单地可以直接运行命令输出以上信息（如果安装了多个版本的 php，那注意使用正确的 php 命令）： php -r phpinfo(); 本地运行一个 php 文件 php [-f] test.php 几种错误提示及对应的解决办法 提示： PHP Fatal error: Uncaught Error: Call to undefined function socket_create() 解决办法： 在 php.ini 文件中配置启用扩展 php_curl.dll。 提示： PHP Fatal error: Uncaught Error: Call to undefined function curl_init() 解决办法： 在 php.ini 文件中配置启用扩展 php_curl.dll。 提示： The openssl extension is required for SSL/TLS protection but is not available. If you can not enable the openssl extension, you can disable this error, at your own risk, by setting the 'disable-tls' option to true 解决办法： 在 php.ini 文件中配置启用扩展 php_openssl.dll。 在开发环境下直接在页面显示出错信息 修改 php.ini 文件，配置 display_errors = On。 安装 Memcache（not Memcached）for php7 当前（2016-10-19）Memcache 扩展并未有官方的支持办法，所以从源码编译安装。 步骤：  下载解压源码 wget https://github.com/websupport-sk/pecl-memcache/archive/NON_BLOCKING_IO_php7.zip unzip NON_BLOCKING_IO_php7.zip cd pecl-memcache-NON_BLOCKING_IO_php7   编译 /usr/local/php7/bin/phpize &amp;&amp; ./configure --enable-memcache --with-php-config=/usr/local/php7/bin/php-config &amp;&amp; make   注意 phpize 和 php-config 要使用 php7 下的。   放置 so 文件到正确位置 cp modules/memcache.so /usr/local/php7/lib/php/extensions/no-debug-non-zts-20151012/memcache.so   目标路径可以在 phpinfo() 的 extension_dir 字段找到。   配置 echo 'extension=memcache.so' &gt; /usr/local/php7/etc/php.d/memcache.ini   目标路径可以在 phpinfo() 的 Scan this dir for addtional .ini files 字段找到。   重启服务使扩展生效 service php-fpm restart   参考 Memcache extension with PHP 7 on CentOS fails to install。 修改 php.ini 后让配置生效 service php-fpm restart ",
      "url"      : "https://blog.shcat.top/wiki/php/",
      "keywords" : "php"
    } ,
  
    {
      "title"    : "PowerShell",
      "category" : "",
      "content": "使用 PowerShell 打造 Windows 下的顺手终端。 与 Cmder 配合使用 搭配 Cmder 一起服用，才最好。 配置文件位置 PowerShell 6 默认配置文件 ~/Documents/WindowsPowerShell/Microsoft.PowerShell_profile.ps1。 PowerShell 7 默认配置文件 &lt;我的文档&gt;/PowerShell/Microsoft.PowerShell_profile.ps1 Cmder 的 PowerShell 配置文件 &lt;cmd_install_path&gt;/config/user-profile.ps1。 alias 快速进入某目录 例：通过 src 命令快速进入 d:  sources   目录。 function Enter-Sources {  cd d:  sources   } Set-Alias src Enter-Sources 快速打开当前文件夹 例：通过 e. 命令快速在资源管理器打开当前文件夹。 function Open-Current-Directory {  explorer . } Set-Alias e. Open-Current-Directory git 相关命令 ## gs=git status function Git-Status {  git status } Set-Alias gs Git-Status ## ga=git add . function Git-Add-All {  git add . } Set-Alias ga Git-Add-All ## gg=gitk function Git-Gui {  gitk } Set-Alias gg Git-Gui ## gpull=git pull origin &lt;current branch&gt; function Git-Pull-Current-Branch {  $currentBranch = git symbolic-ref --short -q HEAD  git pull origin $currentBranch } Set-Alias gpull Git-Pull-Current-Branch ## gpush=git push origin &lt;current branch&gt; function Git-Push-Current-Branch {  $currentBranch = git symbolic-ref --short -q HEAD  git push origin $currentBranch } Set-Alias gpush Git-Push-Current-Branch ## g1=add、commit、push 一条龙 function Git-Commit-And-Push {  git add .  git commit -m $args[0]  Git-Push-Current-Branch } Set-Alias g1 Git-Commit-And-Push objdump function Obj-Dump {  D:  Android  sdk  dk-bundle  toolchains  x86_64-4.9  prebuilt  windows-x86_64  bin  x86_64-linux-android-objdump.exe $args } Set-Alias objdump Obj-Dump 快捷键映射 从 Linux/macOS 的 bash 甚至 Windows 的 cmd 下切换过来后，发现 ctrl-u、ctrl-k 等快捷键不可用了，各种不顺手，PSReadLine 拯救你。 # ctrl-k, ctrl-u, ctrl-a, ctrl-e, ctrl-b, ctrl-f, etc Import-Module PSReadLine Set-PSReadLineOption -EditMode Emacs 常用命令 查看 PATH 环境变量 type env:path 或者将它们每个一行显示： (type env:path) -split ';' 还可以过滤： (type env:path) -split ';' | sls bin 参考  用 PowerShell 快速查看 PATH 环境变量 ",
      "url"      : "https://blog.shcat.top/wiki/powershell/",
      "keywords" : "Windows, PowerShell"
    } ,
  
    {
      "title"    : "Python",
      "category" : "",
      "content": "模块 requests 优雅简单的 HTTP 模块。 BeautifulSoup 很好用的 HTML/XML 解析器。 json JSON 编码解码器。 应用举例：  格式化 JSON 文件 python -m json.tool src.json &gt; dst.json   在 Vim 里格式化 JSON： :%!python -m json.tool   CGIHTTPServer 简单实用的 HTTP 服务器。 应用举例：  运行一个简易的 HTTP 服务器 python -m CGIHTTPServer 80   base64 方便地进行 base64 编解码的模块。 应用举例：  解码 base64 echo aGVsbG93b3JsZA== | python -m base64 -d   则能看到输出 helloworld   问题解决 Your PYTHONPATH points to a site-packages dir 报错信息： ~/github/hs-airdrop$ npm install &gt; bcrypto@5.0.3 install /Users/username/github/hs-airdrop/node_modules/bcrypto &gt; node-gyp rebuild Your PYTHONPATH points to a site-packages dir for Python 3.x but you are running Python 2.x! PYTHONPATH is currently: /usr/local/lib/node_modules/npm/node_modules/node-gyp/gyp/pylib You should `unset PYTHONPATH` to fix this. gyp ERR! configure error gyp ERR! stack Error: `gyp` failed with exit code: 1 gyp ERR! stack  at ChildProcess.onCpExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/configure.js:351:16) gyp ERR! stack  at ChildProcess.emit (events.js:210:5) gyp ERR! stack  at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12) gyp ERR! System Darwin 19.3.0 gyp ERR! command /usr/local/Cellar/node/12.12.0/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js rebuild gyp ERR! cwd /Users/username/github/hs-airdrop/node_modules/bcrypto gyp ERR! node -v v12.12.0 gyp ERR! node-gyp -v v5.0.5 gyp ERR! not ok npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! bcrypto@5.0.3 install: `node-gyp rebuild` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the bcrypto@5.0.3 install script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in: npm ERR!  /Users/username/.npm/_logs/2020-02-19T14_14_34_524Z-debug.log 解决方法： 删除 /usr/local/lib/python3.7/site-packages/ 文件夹下的 sitecustomize.pyc，将 sitecustomize.py 文件重名为 sitecustomize.py~，安装成功之后再改回来。 ",
      "url"      : "https://blog.shcat.top/wiki/python/",
      "keywords" : "Python"
    } ,
  
    {
      "title"    : "Qt Creator",
      "category" : "",
      "content": "快捷键（for mac） 参考：http://doc.qt.io/qtcreator/creator-keyboard-shortcuts.html C –&gt; Ctrl S –&gt; Shift M –&gt; Alt Cmd –&gt; Command    功能  快捷键     自动完成  C-Space    显示/隐藏侧边栏  Cmd-0    切换已打开的文件  M-Tab    上/下一行  C-p/C-n    前进/后退一个字符  C-f/C-b    删除一个单词  M-Del    构建  Cmd-b    运行  Cmd-r    调试  Cmd-y    注释  Cmd-/    换行  Cmd-Return    跳到定义  F2    切换头文件与源文件  F4    前进/后退  M-Cmd-Left/Right    打开定位器  Cmd-k  ",
      "url"      : "https://blog.shcat.top/wiki/qt-creator/",
      "keywords" : "Qt, Qt Creator"
    } ,
  
    {
      "title"    : "Scoop",
      "category" : "",
      "content": "指定 Scoop 安装目录 环境变量： SCOOP='D:  Applications  Scoop' 指定安装程序自定义目录 设置 SCOOP 环境变量后，程序会默认安装在 %SCOOP%  apps 目录下。 还可以自定义全局安装目录： SCOOP_GLOBAL='D:  Applications  ScoopApps' 这样需要 scoop install -g &lt;appname&gt; 来全局安装，需要使用管理员权限执行。 加快下载速度 scoop install aria2 软件下载 安装到默认目录： scoop install &lt;appname&gt; 安装到全局安装目录： scoop install -g &lt;appname&gt; 软件搜索： scoop search &lt;appname&gt; 列出已知 bucket： scoop bucket known 添加 bucket： scoop bucket add &lt;bucketname&gt; 查看软件信息 列出已安装软件： scoop list 查看某软件信息： scoop info &lt;appname&gt; ",
      "url"      : "https://blog.shcat.top/wiki/scoop/",
      "keywords" : "scoop, windows"
    } ,
  
    {
      "title"    : "Skill Tree",
      "category" : "",
      "content": "# 技能树 ## Java 后端开发 ## Android 开发 ## Windows 开发 ## 通用技能 ### 操作系统 #### Windows #### Linux #### macOS ### 编辑器 #### Vim #### Visual Studio Code ### 标记语言 #### Markdown ### 版本控制 #### Git #### SVN ",
      "url"      : "https://blog.shcat.top/wiki/skill-tree/",
      "keywords" : "技能树, 思维导图, mindmap, 脑图"
    } ,
  
    {
      "title"    : "Source Insight",
      "category" : "",
      "content": "快捷键 C –&gt; Ctrl S –&gt; Shift M –&gt; Alt    功能  快捷键     返回  M-,    前进  M-.    跳到定义  C-=    查找引用  C-/    搜索  C-f    向下搜索  F4    向上搜索  F3    高亮当前单词  S-F8   Q&amp;A  新建工程后函数跳转等遇到 symbol not found 如何解决？ 打开菜单里的「Project」-「Synchronize Files」（快捷键 Alt + Shift + S），勾选 Force all files to be re-parsed 后点击 OK，等待 Source Insight 重新解析工程里的文件完成即可。   如何在标题栏里显示文件全路径？ 打开菜单里的「Options」-「Preferences」-「Display」，取消勾选 Trim long path names with ellipses。  ",
      "url"      : "https://blog.shcat.top/wiki/source-insight/",
      "keywords" : "Source Insight"
    } ,
  
    {
      "title"    : "Swimming",
      "category" : "",
      "content": "蛙泳 我目前能游出最远距离的泳姿。 视频  蛙泳教学完整版 动作时序图 要领  先划手，后收腿，先伸胳膊后蹬腿。 腿部动作时一定要勾脚，大腿不要收太多。 收腿放松，蹬腿用力，蹬完一定要漂一会，把握好节奏，不要快蹬快收。 手部划水动作不要过大，不要超过肩部。 两手开始外分时就抬头吸气。 自由泳 视频  值得一看的自由泳教学视频 ",
      "url"      : "https://blog.shcat.top/wiki/swimming/",
      "keywords" : "游泳, 蛙泳"
    } ,
  
    {
      "title"    : "Wiki Template",
      "category" : "",
      "content": "Content here ",
      "url"      : "https://blog.shcat.top/wiki/template/",
      "keywords" : "keyword1, keyword2"
    } ,
  
    {
      "title"    : "Vim",
      "category" : "",
      "content": "移动 以字（符）为单位    功能  按键     上  k    下  j    左  h    右  l   以单词为单位    功能  按键     前一个单词尾  ge    后一个单词首  w    本单词首（已在本词首则跳到前一单词首）  b    本单词尾（已在本词尾则跳到后一单词尾）  e   以屏幕为单位    功能  按键     向下翻页  CTRL-f    向上翻页  CTRL-b    向下翻半页  CTRL-d    向上翻半页  CTRL-u    向上一行  CTRL-y    向下一行  CTRL-e    光标移到屏幕上方  H    光标移到屏幕中间  M    光标移到屏幕下方  L    光标所在位置移到屏幕上方  zt    光标所在位置移到屏幕中间  zz    光标所在位置移到屏幕下方  zb   行号    功能  按键     跳到第 num 行  :num 或 numG 或 numgg   文件    功能  按键     跳到文件头  gg    跳到文件尾  G   编辑 复制    功能  按键     复制光标所在单词  yiw    复制光标所在行  yy   粘贴    功能  按键     在光标之后粘贴  p    在光标之前粘贴  P   剪切    功能  按键     剪切选中区域  d    剪切光标所在行  dd   替换    功能  按键     将全文中的 str1 替换为 str2  :%s/str1/str2/g    将 1 到 5 行中的 str1 替换为 str2  :1,5s/str1/str2/g   大小写    功能  按键     将选中内容大小写互换  ~    将选中内容全转为小写  gu    将选中内容全转为大写  gU    将当前行变成小写  guu    将当前行变成大写  gUU    将匹配内容替换为大写  :%s/xxx/  U&amp;/g    将匹配内容替换为小写  :%s/xxx/  L&amp;/g   注：&amp; 代表正则表达式全部匹配项，另外还有   1、’  2’、…、  9 代表第 1 到 9 个匹配项。 选择    功能  按键     选中上一次选择的区域  gv    选中括号内区域  vi{、vi[、vi(   搜索    功能  按键     向下查找字符串  /str    向上查找字符串  ?str    查找下一个  n    查找上一个  N    向下查找光标所在单词  *    向下查找光标所在单词  #   正则表达式    功能  按键     匹配单词左边界    &lt;    匹配单词右边界    &gt;    去重  :g/^  (.*  )$    1/d   常用    功能  按键     删除空行  :g/^$/d    撤销/UNDO  u    重做/REDO  C-r    统计行/单词/字符/字节数  g C-g    去掉 UTF-8 BOM  :set nobomb    保留 UTF-8 BOM  :set bomb   全局    功能  按键     退出  :q    强制执行  !    执行外部命令  :!   文件操作    功能  按键     打开  :e    打开文件对话框  :bro e    保存  :w    另存为对话框  :bro w    查看历史文件列表  :ol    查看并打开历史文件  :bro ol    重命名当前文件  :f filename   vimdiff    功能  按键     移动到上一个不同处  [c    移动到下一个不同处  ]c    该差异点使用当前文件的  dp    该差异点使用其它文件的  do    手动刷新重新比较  :diffupdate   Buffer    功能  按键     查看 Buffer 列表  :ls    转到 Buffer 列表中的下一个 Buffer  :bn    转到 Buffer 列表中的上一个 Buffer  :bp    转到 Buffer 列表中的 num 号 Buffer  :bnum    你之前待过的一个 Buffer  :b#    从 Buffer 列表中删除 num 号 Buffer  :bdnum   组合命令 可以使用 | 来组合命令，比如 cmd1 | cmd2。 代码    功能  按键     格式化代码  gg=G    去除 1-20 行首的行号  :1,20s/^    s  *[0-9]  *    s  *//g    展开全部折叠  zR    展开当前层级折叠  zr    全部折叠  zM    当前层级折叠  zm    切换折叠/展开  za    递归折叠/展开当前大区块  zA    折叠当前区块  zc    递归折叠当前大区块  zC    展开当前区块  zo    递归展开当前大区块  zO    格式化 json 数据  :%!python -m json.tool    缩进当前行  &gt;&gt;    反缩进当前行  &lt;&lt;   modeline 写法： vim: set ft=markdown: vim: ft=markdown // vim: noai:ts=4:sw=4 /* vim: noai:ts=4:sw=4 */ 插件 CtrlP 基础按键 C-p    功能  按键     刷新列表  F5    切换文件/缓冲区/MRU  C-f/b    切换全路径搜索/文件名搜索  C-d    切换正则表达式模式  C-r    上/下一个选项  C-k/j    在新标签/垂直分割/水平分割打开文件  C-t/v/x    历史选择记录的上/下一条  C-p/n    创建文件和它的父路径  C-y    标记并打开多个文件  C-z C-o    退出 CtrlP  C-c   LeaderF    功能  按键     打开文件  Leader-f    打开缓冲区  Leader-b    打开 MRU  Leader-m（自定义的）    退出  C-c    切换模糊查找和正则查找  C-r    粘贴  C-v    清空输入  C-u    上/下一个选项  C-k/j    在新标签/垂直分割/水平分割打开文件  C-t/]/v    刷新列表  F5   vim-table-mode    功能  按键     删除列  Leader-tdc    删除行  Leader-tdd    重新格式化表格  Leader-tr   markdown-preview.nvim    功能  按键     预览  F5    停止预览  F6   导出 PDF：预览以后，使用浏览器的「打印」功能，打印机选「另存为 PDF」，取消「页眉和页脚」，然后点保存即可。 命令行 打开 Vim 时跳转到指定行： vim +[num] filename num 表示行号，不填则跳转到文件末尾。 ",
      "url"      : "https://blog.shcat.top/wiki/vim/",
      "keywords" : "Vim"
    } ,
  
    {
      "title"    : "Visio",
      "category" : "",
      "content": "小问题记录 连接线箭头 如果在 Visio 2013/2016 里画流程图，发现连接线没有箭头，检查一下「设计」菜单里是否将主题设置成了「无主题」，如果是，取消掉就好了。 鼠标悬停提示 把鼠标悬停在图形上四周应该有几个小三角提示，如果没有，检查「视图」里是否勾选了「自动连接」，如果没有，勾选上。 调整导出 PNG 大小 导出 PNG 时，填好保存位置和文件名之后，会弹出一个「PNG 输出选项」，在其中调整大小即可。 ",
      "url"      : "https://blog.shcat.top/wiki/visio/",
      "keywords" : "Visio"
    } ,
  
    {
      "title"    : "Visual Studio Code",
      "category" : "",
      "content": "快捷键 C –&gt; Ctrl S –&gt; Shift M –&gt; Alt Cmd –&gt; Command    功能  Windows  Mac OS X     打开文件  C-o       打开文件夹  C-k C-o       关闭文件夹  C-k f       命令面板  C-S-p       资源管理器  C-S-e       搜索  C-S-f       Git  C-S-g       调试  C-S-d       插件  C-S-x       Markdown 侧边预览  C-k v       Markdown 预览  C-S-v      使用 VSCode 作为 mergetool 编辑 ~/.gitconfig 文件，添加如下内容： [merge]  tool = vscode [mergetool vscode]  cmd = code --wait $MERGED 需要的时候执行 git mergetool 就会调起了。 参考：https://blog.kulman.sk/using-vscode-as-git-merge-tool/ 使用 VSCode 作为 git commit message 编辑器 git config --global core.editor code -w VSCodeVim 支持按键重复 在 macOS，默认情况 VSCodeVim 模式下是不支持按键重复的，比如你在 Normal 模式下长按 L，结果光标只向右移动了一次，而没有像你预期的那样一直移动。 启用按键重复的方法在插件的 REAME 有说明，链接：https://github.com/VSCodeVim/Vim#mac 方法： 按需执行下面的某一行命令并重启 VSCode。 $ defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool false  # For VS Code $ defaults write com.microsoft.VSCodeInsiders ApplePressAndHoldEnabled -bool false # For VS Code Insider $ defaults write com.visualstudio.code.oss ApplePressAndHoldEnabled -bool false # For VS Codium $ defaults delete -g ApplePressAndHoldEnabled       # If necessary, reset global default 如果有需要，调整「系统偏好设置」—「键盘」里的「按键重复」和「重复前延迟」。 ",
      "url"      : "https://blog.shcat.top/wiki/visual-studio-code/",
      "keywords" : "Visual Studio Code"
    } ,
  
    {
      "title"    : "Visual Studio",
      "category" : "",
      "content": "地球上最好用的 C++ 开发环境，没有之一。现在也有免费的社区版了，可惜以前密集写 C++ 代码的时候没赶上。 快捷键    功能  快捷键     快速打开 anything  C-,    当前打开文件  C-M-Down    切换头/源文件  C-ko    返回  C–    前进  C-S–    跳转到定义  F12    在新窗口展示定义  M-F12    跳转到声明  C-M-F12    上/下移动行  M-Up/Down    在上面插入行  C-Enter    在下面插入行  C-S-Enter    折叠/展开当前代码段  C-mm    注释  C-kc    取消注释  C-ku    选中单词大写  C-S-u    选中单词小写  C-u    调试  F5    执行  C-F5    设置断点  F9    步过  F10    步入  F11   插件  Go To Definition Make ctrl+click perform a “Go To Definition” on the identifier under the cursor.   Visual Assist Productivity tool for C/C++ and C# that improves IDE features related to navigation, refactoring, code generation, and coding assistance. 参考  visual studio 2013 快捷键大全、VS2013常用快捷键完整页 ",
      "url"      : "https://blog.shcat.top/wiki/visual-studio/",
      "keywords" : "Visual Studio"
    } ,
  
    {
      "title"    : "微信",
      "category" : "",
      "content": "最常用的软件，也有一些不易发现但有用的小技巧。 发送 APK 文件到手机 通过微信发送 .apk 文件到安卓手机后，文件名会变成 .apk.1，在手机上保存后存放位置为  内部存储设备 &gt; Tencent &gt; MicroMsgs &gt; Download 在文件管理器里按修改时间排序即可快速找到，将其重命名去掉 .1 之后即可正常打开。 设置当电脑微信在线时，手机微信关闭消息通知 手机和电脑微信同时在线时，在手机上打开微信，可以看到顶部有一个条，显示「XX 微信已登录，XXX」： 点击它，可以打开以下界面，圈出来的按钮即可开/关当电脑微信在线时，手机微信消息通知。 ",
      "url"      : "https://blog.shcat.top/wiki/wechat/",
      "keywords" : "微信, wechat"
    } ,
  
    {
      "title"    : "Windows Terminal",
      "category" : "",
      "content": "Windows Terminal 是微软打造的一款新的控制台终端，目前还在 Preview 版本，但经过一些配置已经可以用得不错。 自定义主题 可以到 https://github.com/mbadolato/iTerm2-Color-Schemes 的 windowsterminal 下寻找合适的主题。 自定义配置文件位置 我想将配置文件放到 HOME 目录下，然后通过 git 管理，通过以下办法可以做到： 首先剪切 ~/AppData/Local/Packages/Microsoft.WindowsTerminal_8wekyb3d8bbwe/RoamingState/profiles.json 文件到 ~/Windows-terminal-profiles.json，然后管理员权限打开 PowerShell，执行 New-Item -ItemType SymbolicLink -Path ~/AppData/Local/Packages/Microsoft.WindowsTerminal_8wekyb3d8bbwe/RoamingState/profiles.json -Target ~/windows-terminal-profiles.json 我的 Windows Terminal 文件见 https://github.com/mzlogin/config-files/blob/master/windows-terminal-profiles.json 通过 git 管理 PowerShell 配置 管理员权限打开 PowerShell，执行 New-Item -ItemType SymbolicLink -Path ~/Documents/WindowsPowerShell/Microsoft.PowerShell_profile.ps1 -Target ~/powershell.ps1 如果是使用 PowerShell 7 Preview，执行 New-Item -ItemType SymbolicLink -Path &lt;我的文档&gt;/PowerShell/Microsoft.PowerShell_profile.ps1 -Target &lt;个人目录&gt;/powershell.ps1 上面两个目录需要使用绝对路径，不然会报错。 我的 PowerShell 配置见 https://github.com/mzlogin/config-files/blob/master/powershell.ps1 自定义快捷键 比如在 json 配置文件的 globals – keybindings 里添加如下内容，可以将 Windows Terminal 的复制粘贴映射为 ctrl+c 和 ctrl+v（这里真的要吐槽下，为什么不给默认映射上呢？）： Updated 2020-04-26： 下面这些不用再手动映射了，新版本里都给了默认映射。 { command: copy, keys: [ctrl+c] }, { command: paste, keys: [ctrl+v] } split pane 和 move focus within panes： { command : splitHorizontal, keys: [ alt+- ] }, { command : splitVertical, keys: [ alt+     ] }, { command : closePane, keys: [ alt+w ] }, { command : moveFocusLeft, keys: [ alt+left ] }, { command : moveFocusRight, keys: [ alt+right ] }, { command : moveFocusUp, keys: [ alt+up ] }, { command : moveFocusDown, keys: [ alt+down ] } 参考：https://github.com/microsoft/terminal/blob/master/doc/user-docs/UsingJsonSettings.md ",
      "url"      : "https://blog.shcat.top/wiki/windows-terminal/",
      "keywords" : "Windows Terminal"
    } ,
  
    {
      "title"    : "Mac 清理磁盘空间",
      "category" : "",
      "content": "Mac 使用久了之后，磁盘空间会逐渐被占据，直至开始影响正常使用，让不富裕的家庭雪上加霜。 这里介绍一种比较直观的清理磁盘空间的方法，不需要安装任何软件，直接通过系统自带的访达程序操作。 操作步骤：  打开访达，在访达的「偏好设置」-「边栏」里勾选「硬盘」；   点击菜单栏「显示」-「查看显示选项」，排序方式选「大小」,勾选「大小」和「计算所有大小」，然后点击「用作默认」；    点击访达边栏的 Machintosh HD，切换到列表视图，并按「大小」倒序排列；  等它计算一会，然后就可以知道什么文件夹占用了最多的空间，依次展开占用空间最多的文件夹，找到可以删除的文件/文件夹，移到废纸篓并清理掉。 常见的几个重灾区位置：  /Library ~/Library ",
      "url"      : "https://blog.shcat.top/fragment/mac-clean-up-disk-space/",
      "keywords" : "Mac, clean up disk space"
    } ,
  
    {
      "title"    : "Mac 下删除 zip 文件里的隐藏文件",
      "category" : "",
      "content": "使用 Mac 自带的压缩功能，打出来的 zip 包里面会打入像 .DS_Store 和 __MACOSX 这些东西，在有些场景下需要将它们清除。 这时，可以使用以下命令： zip -d 归档.zip __MACOSX* zip -d 归档.zip *.DS_Store 或者，创建一个如下内容的 cleanzip.sh 文件，放到 PATH 环境变量包含的路径里面，然后在需要时执行 cleanzip 归档.zip 即可： zip -d $1 __MACOSX* zip -d $1 *.DS_Store 参考：如何取消macOS压缩时生成的「_MACOSX」的隐藏文件夹？ - 知乎 ",
      "url"      : "https://blog.shcat.top/fragment/mac-clean-zip/",
      "keywords" : "Mac, zip, DS_Store, MACOSX"
    } ,
  
    {
      "title"    : "Mac 下让 Spotlight 显示英汉汉英互译",
      "category" : "",
      "content": "Mac 下的 Spotlight（即「聚焦」）可以很方便地启动应用、搜索文件等，我常用的还有一个功能就是当作英汉汉英词典使用。 我期望的行为：  在搜索框中输入中文，出现的提示列表里有一项是它的英文翻译； 在搜索框中输入英文，出现的提示列表里有一项是它的中文翻译。 实际使用时发现行为 1 默认就是有的，但行为 2 没有。 需要简单的配置：  在「系统偏好设置」的「聚焦」里确认「定义」是勾选上的； 打开「词典.app」的偏好设置，将英汉汉英词典勾选并拖到第一位； 如果不生效，可以重启下电脑。 效果图： 参考：让spotlight 显示中英翻译 - 钜添 ",
      "url"      : "https://blog.shcat.top/fragment/mac-spotlight-c2ee2c/",
      "keywords" : "Mac, Spotlight, 翻译"
    } ,
  
    {
      "title"    : "Maven 项目引用本地 jar 包",
      "category" : "",
      "content": "我们现在 Java 项目一般都使用 Maven 进行依赖管理，二方包三方包都是从公司的私服远程拉取。最近做一个外采系统的二次开发，SDK 只提供离线 jar 包，这样我们就得想办法告诉 Maven 同时引入远程和本地的依赖，并且在打包时包含本地依赖。  将 xxxSDK.jar 包拷贝进项目，比如 src/lib 里；   在 pom.xml 文件里新增 dependency：  &lt;dependency&gt; &lt;groupId&gt;com.xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx-sdk&lt;/artifactId&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;version&gt;${xxxSDK.version}&lt;/version&gt; &lt;systemPath&gt;${project.basedir}/src/lib/xxxSDK.jar&lt;/systemPath&gt; &lt;/dependency&gt;   注意 scope 是 system，表明是基于文件系统，配合 systemPath 查找。 groupId、artifactId、version 可以按实际情况瞎写。   在 pom.xml 里添加 &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;指定打包的时候将引用的本地 jar 也打包进去，比如 SpringBoot 项目的：  &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;!-- 加以下配置 --&gt; &lt;configuration&gt;  &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt; &lt;/configuration&gt; &lt;/plugin&gt;   好了大功告成。 后续问题：  打包后运行时，报错 Correct the classpath of your application so that it contains a single, compatible version of，这是由于包冲突，可以排除冲突包，只保留一个正确版本解决，如果无法排除（比如从本地 jar 包引入的），则可以调整 dependency 顺序，将正确版本放在最前面。 参考：Maven项目引用本地jar包_xiaowu&amp;的博客-CSDN博客_maven引入本地jar ",
      "url"      : "https://blog.shcat.top/fragment/maven-include-local-jar/",
      "keywords" : "Maven, Java"
    } ,
  
    {
      "title"    : "Maven 项目只在某台机器上报找不到某个类",
      "category" : "",
      "content": "一个 Maven 项目在我的机器上能正常编译运行，但在一个同事那里不行，一直报找到不某个类。 试过 Reimport、mvn clean、重启 IDEA、重启机器，也还是一样。 确认该类所属的依赖包是正常引入的，包冲突已解决，版本也正确。 唯一异常的地方是在 IDEA 的 Project 视图里的 External Libraries 里，正常的依赖包是能够展开看里面的类的，但该类所属依赖包无法展开。 最后打开 Maven 的本地存储（比如我的是 ~/.m2 目录），才发现该依赖包对应的 jar 包是 0 字节，将它删除后 Reimport，问题解决。 ",
      "url"      : "https://blog.shcat.top/fragment/maven-zero-byte-jar/",
      "keywords" : "Java, Maven"
    } ,
  
    {
      "title"    : "Fragment Template",
      "category" : "",
      "content": "Content here ",
      "url"      : "https://blog.shcat.top/fragment/template/",
      "keywords" : "keyword1, keyword2"
    } 
  
]

